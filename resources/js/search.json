[[{"l":"Workshop Home","p":["For the source code for the workshop, visit the HTMX for Razor Pages Workshop GitHub repo.","Ask me about doing a workshop. My email is cwoodruff@live.com."]}],[{"l":"Introduction to the Workshop","p":["Welcome to this online workshop on leveraging HTMX to enhance your ASP.NET Razor Pages and revolutionize your server-side web development. In today's fast-paced digital landscape, the need for highly responsive, interactive, and efficient web applications is paramount. As developers, we constantly seek ways to streamline our workflows, improve user experiences, and optimize performance. HTMX is an innovative tool that allows us to achieve these goals by enabling a more seamless interaction between client and server without the complexity of single-page applications (SPAs).","HTMX, or Hypertext Markup Extensions, is a modern JavaScript library that empowers you to build dynamic and interactive web pages with minimal JavaScript. Unlike traditional SPAs, which often require substantial front-end frameworks and can be cumbersome to manage, HTMX allows you to keep your focus on server-side logic while still delivering a rich, interactive experience to your users. This workshop will explore how HTMX can be integrated into your existing ASP.NET Razor Pages applications, providing a pragmatic approach to developing feature-rich web applications without sacrificing simplicity and maintainability.","Throughout this workshop, we will explore the core concepts of HTMX and how it can enhance Razor Pages by adding dynamic content loading, seamless form submissions, and real-time updates—all without needing to write excessive JavaScript. We'll examine how HTMX's declarative approach aligns with the principles of server-side development, making it a perfect fit for ASP.NET developers looking to modernize their web applications while maintaining control over their server-side code.","By the end of this workshop, you'll have a solid understanding of how to implement HTMX in your projects, allowing you to create faster, more responsive web applications with a fraction of the effort typically associated with modern front-end development. Whether you're looking to improve existing Razor Pages applications or start new projects with an eye toward simplicity and performance, this workshop will equip you with the knowledge and tools to do so effectively.","We are excited to have you join us in enhancing your web development skills. We look forward to exploring the powerful combination of HTMX and ASP.NET Razor Pages. Let's start by transforming how you approach building dynamic and efficient web applications."]}],[{"l":"Installing .NET 10 and ASP.NET 10","p":["This page will instruct you how to download and install the .NET 7 SDK, including ASP.NET 10 Web API.","First, download the .NET SDK on your computer."]},{"l":"Installing the SDK for .NET 10","p":["Next, install the .NET SDK on your computer.","Next, open a terminal such as PowerShell, Command Prompt, or bash. Enter the following dotnet commands to verify that .NET 10 has been installed:","You see the .NET 10 SDK version as one of the outputs:","Congratulations! You're ready to create your first ASP.NET Web API."]},{"l":"Next steps","p":["If you need some introduction to developing .NET applications, you can follow the step-by-step tutorial or watch .NET 101 videos on YouTube."]}],[{"l":"About the Workshop"}],[{"l":"License for the Workshop","p":["The MIT License (MIT) Copyright © 2023","Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”) to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:","The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.","THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."]}],[{"l":"Foundations: Hypermedia + htmx Mental Model"}],[{"l":"Lab 1: Baseline Razor Pages App + “Fragment First”"}],[{"l":"Lab 2: Partial Updates with hx get + hx post"}],[{"l":"Checkpoint: Troubleshooting + Pattern Review"}],[{"l":"Lab 3: Real Time Validation and Form UX"}],[{"l":"Lab 4: Core UX Patterns (Modal, Confirm, History, Pagination)"}],[{"l":"Checkpoint: Make It Production Livable"}],[{"l":"Lab 5: Dynamic Forms + Long Running UX (Polling)"}],[{"l":"Capstone Hardening + Take-Home Extensions"}],[{"l":"Workshop UI Examples","p":["Active Search","Animations","Bulk Update","Click To Edit","Click To Load","Delete Row","Demonstrates a job-runner like progress bar","Demonstrates bulk updating of multiple rows of data","Demonstrates clicking to load more rows in a table","Demonstrates how to create keyboard shortcuts for htmx enabled elements","Demonstrates how to display and select tabs using HATEOAS principles","Demonstrates how to do inline field validation","Demonstrates how to edit rows in a table","Demonstrates how to lazy load content","Demonstrates how to upload a file via ajax with a progress bar","Demonstrates how to use htmx with the Sortable.js plugin to implement drag-and-drop reordering","Demonstrates infinite scrolling of a page","Demonstrates inline editing of a data object","Demonstrates making the values of a select dependent on another select","Demonstrates modal dialogs from scratch","Demonstrates modal dialogs using UIKit","Demonstrates row deletion in a table","Demonstrates the active search box pattern","Demonstrates the prompt and confirm dialogs using Bootstrap","Demonstrates various animation techniques","Description","Dialogs - Bootstrap","Dialogs - Custom","Dialogs - UIKit","Drag & Drop with Sorting","Edit Row","File Upload","htmx examples on Azure.","Infinite Scroll","Inline Validation","Keyboard Shortcuts","Lazy Loading","Pattern","Progress Bar","Tabs--","Value Select","You can find all exaples running in Azure to test and explore."]}],[{"l":"Active Search"},{"l":"Implementing Active Search with htmx and ASP.NET Core","p":["The Active Search pattern is one of the most popular use cases for htmx, providing a \"search-as-you-type\" experience without the complexity of a full-blown JavaScript framework. Here's a look at how it's implemented in our ActiveSearch demo."]},{"l":"The Frontend: Razor & htmx","p":["In Index.cshtml, we define a search input that triggers a request to the server as the user types.","Key htmx attributes used:","hx-post: Tells htmx to make a POST request to the Search handler on the current Page.","hx-trigger: Specifies when to fire the request. We use keyup changed delay:500ms so it only fires 500ms after the user stops typing, avoiding excessive server hits.","hx-target: Tells htmx where to put the returned HTML (in this case, our table body).","hx-indicator: Shows a loading spinner while the request is in flight."]},{"l":"The Backend: C# PageModel","p":["On the server side in Index.cshtml.cs, we handle the search request. The OnPostSearch method fetches data from an external API (REST Countries) based on the input and returns a partial view."]},{"l":"The Result: Partial View","p":["Finally, _searchResult.cshtml renders just the rows needed for the table:","This approach keeps the logic simple, the state on the server, and the UI fast and responsive."]}],[{"l":"Bulk Update"},{"l":"Implementing Bulk Updates with htmx and ASP.NET Core","p":["The Bulk Update pattern demonstrates how to handle multiple record updates efficiently using htmx. This approach allows users to select several items from a list and perform an action on all of them at once, with the UI updating dynamically to reflect the changes."]},{"l":"The Frontend: Razor & htmx","p":["In Index.cshtml, we have a set of buttons and a table wrapped in a form. The buttons use hx-include to pull in the selected checkboxes.","Key htmx attributes used:","hx-put: Sends a PUT request to the specified page handler ( OnPutActivate or OnPutDeactivate).","hx-include: Ensures that the values from the #checked-contacts form (specifically the checked checkboxes named ids) are included in the request, even though the buttons are outside the form.","hx-target: Specifies that the returned HTML should replace the content of the tbody with the ID tbody."]},{"l":"The Backend: C# PageModel","p":["The Index.cshtml.cs file handles the bulk update logic. It receives an array of IDs from the checked checkboxes and updates the corresponding contacts via a service."]},{"l":"The Result: Partial View","p":["The _tbody.cshtml partial view renders the table rows. It also applies CSS classes to rows that were just updated to provide visual feedback.","By using hx-include, we decouple the action buttons from the form structure, and by returning a partial view, we update only the necessary part of the page, making the application feel much more responsive."]}],[{"l":"Click to Edit"},{"l":"Implementing Click-to-Edit with htmx and ASP.NET Core","p":["The Click-to-Edit pattern is a sleek way to provide inline editing capabilities. Instead of redirecting to a separate edit page, htmx allows you to swap the display view with an edit form in-place, and then swap back once the update is complete."]},{"l":"1. The Display State","p":["Initially, we show the contact information. The container is configured to handle the swap when an inner element triggers an htmx request.","_DisplayContactForm.cshtml","hx-target=this: Tells htmx to replace the current div with the response.","hx-swap=outerHTML: Ensures the entire div is replaced, not just its content.","hx-get: Requests the edit form from the EditContact handler."]},{"l":"2. The Edit State","p":["When the \"Click To Edit\" button is pressed, the server returns a partial view containing the form.","_EditContactForm.cshtml","hx-put: Submits the form data to the ReplaceContact handler.","The \"Cancel\" button uses hx-get to fetch the display version again, discarding changes."]},{"l":"3. The Backend: C# PageModel","p":["The Index.cshtml.cs file manages the transitions between these states by returning the appropriate partial views.","Index.cshtml.cs"]},{"l":"Summary","p":["This pattern provides a very \"app-like\" feel. By swapping small fragments of HTML, you avoid full page reloads and maintain the user's scroll position and context, all while keeping your logic cleanly separated in Razor Pages and C#."]}],[{"l":"Click to Load"},{"l":"Implementing Click-to-Load with htmx and ASP.NET Core","p":["The Click-to-Load pattern is a great alternative to traditional pagination or infinite scroll. It allows users to load more data only when they explicitly request it, keeping the initial page load light while providing a smooth way to browse through larger datasets."]},{"l":"The Frontend: Razor & htmx","p":["In Index.cshtml, we start with an initial set of data and a \"Load More\" button (contained within a partial view).","Index.cshtml","The magic happens in the partial view. When the user clicks the button, htmx fetches the next page and replaces the entire row containing the button with the new data and a new button for the subsequent page.","_ClickToLoadButton.cshtml","Key htmx attributes used:","hx-get: Requests the next page of results from the server.","hx-target=#replaceMe: Targets the specific table row that currently holds the button.","hx-swap=outerHTML: Replaces the target row with the new rows and the next \"Load More\" button."]},{"l":"The Backend: C# PageModel","p":["The IndexModel handles the logic for fetching paged data. It uses ViewData to keep track of the current page number so the partial view knows what page to request next.","Index.cshtml.cs"]},{"l":"Why this works well","p":["Reduced Initial Payload: You only send the first few records to the browser.","Server-Side State: The server dictates what the next \"page\" is by providing the URL in the new \"Load More\" button.","Seamless Integration: New rows are appended to the table naturally, maintaining the user's scroll position while extending the list.","Simplicity: No complex JavaScript state management is required to track offsets or append elements to the DOM."]}],[{"l":"Delete Row"},{"l":"Implementing Row Deletion with htmx and ASP.NET Core","p":["The Delete Row pattern is a common requirement in data-driven applications. Using htmx, you can remove a record from the database and concurrently update the UI by removing the corresponding row from a table—all without a full page reload."]},{"l":"The Frontend: Razor & htmx","p":["In Index.cshtml, we set up a table where the tbody is configured to handle the deletion logic for all its child rows.","Index.cshtml","The individual rows are rendered via a partial view. Each row contains a \"Delete\" button that triggers the htmx request.","_TableRow.cshtml","Key htmx attributes used:","hx-confirm: Automatically triggers a browser confirmation dialog before the request is sent.","hx-post: Sends a POST request to the Contact handler with the specific contact's ID.","hx-target=closest tr: (Defined on the parent tbody) Tells htmx to target the table row containing the clicked button.","hx-swap=outerHTML swap:1s: Replaces the entire row with the server response (which is empty in this case). The swap:1s allows for a CSS transition effect (like a fade-out) before the element is finally removed from the DOM.","hx-include=closest form: Ensures the Anti-Forgery Token from the form is included in the POST request."]},{"l":"The Backend: C# PageModel","p":["The IndexModel handles the deletion request. When the record is successfully deleted from the service, it returns an OkResult. Since the response body is empty, htmx simply removes the target element (the row) from the page.","Index.cshtml.cs"]},{"l":"Why this works well","p":["Declarative UI: You define the confirmation and targeting logic once on the container ( tbody), making the individual row templates cleaner.","Visual Feedback: By using swap:1s, you can use CSS transitions to provide a smooth removal animation, making the UI feel more polished.","Low Overhead: The server only needs to return a simple 200 OK status, minimizing bandwidth and processing time.","Security: The use of [ValidateAntiForgeryToken] and hx-include=closest form ensures that the deletion requests are protected against CSRF attacks."]}],[{"l":"Edit Row"},{"l":"Implementing Row Editing with htmx and ASP.NET Core","p":["The Edit Row pattern allows users to edit individual rows in a table without leaving the page or opening a modal. By leveraging htmx, we can swap a static table row for an editable version and then swap it back once the update is complete."]},{"l":"1. The Table Structure","p":["In Index.cshtml, we define a table where the tbody is configured to handle the swap target for any htmx request originating from its children.","Index.cshtml","hx-target=closest tr: This tells htmx that the result of any request within this body should target the nearest table row.","hx-swap=outerHTML: Replaces the entire tr element with the response from the server."]},{"l":"2. The Read-Only Row","p":["Initially, each contact is rendered using a read-only partial view. The \"Edit\" button triggers a GET request to fetch the editable version of that specific row.","_TableRow.cshtml"]},{"l":"3. The Editable Row","p":["When the \"Edit\" button is clicked, the server returns the _EditRow.cshtml partial. This row contains input fields and action buttons.","_EditRow.cshtml","hx-include=closest tr: Ensures that the values of the input fields in the current row are included in the PUT request.","The \"Cancel\" button simply fetches the read-only row again, discarding any unsaved changes."]},{"l":"4. The Backend: C# PageModel","p":["The IndexModel handles the transitions between states. It provides handlers for entering edit mode, canceling/viewing, and performing the update.","Index.cshtml.cs"]},{"l":"Summary","p":["This pattern keeps the user in the flow of their data. By targeting only the \"closest tr\", htmx makes it easy to manage row-level state without complex JavaScript selectors or managing a global state object. The transition between \"view\" and \"edit\" modes is seamless and extremely responsive."]}],[{"l":"Drag & Drop with Sorting"},{"l":"Implementing Drag-and-Drop Sorting with htmx and ASP.NET Core","p":["The Drag-and-Drop Sortable pattern demonstrates how to integrate a specialized JavaScript library like Sortable.js with htmx to create a reorderable list that syncs its state with the server automatically. This provides a highly intuitive UI for managing sequences or priorities."]},{"l":"1. The Frontend: Sortable.js & htmx","p":["In Index.cshtml, we wrap our list in a form. We use a small Hyperscript block to initialize the Sortable.js library and bridge its events over to htmx.","Index.cshtml","Key htmx and Hyperscript attributes:","hx-post=?handler=Reorder: Specifies the server endpoint to receive the new order.","hx-trigger=end: htmx waits for a custom DOM event named end to be fired before sending the request.","on load or htmx:afterSwap: Hyperscript ensures that Sortable.js is initialized (or re-initialized after a swap) on the list element.","onEnd: function() { htmx.trigger(...) }: Inside the Sortable.js configuration, we manually trigger the end event that htmx is listening for whenever a drag operation finishes."]},{"l":"2. The Item List Partial","p":["The list items contain a hidden input. When Sortable.js reorders the DOM elements, these inputs move with them. When htmx submits the form, it sends these IDs in their new order.","_ItemList.cshtml"]},{"l":"3. The Backend: C# PageModel","p":["The server receives an array of integers representing the IDs in the order they appear in the DOM. It updates the database (or in-memory store) accordingly and returns the updated list fragment.","Index.cshtml.cs"]},{"l":"Why this works well","p":["Best of Both Worlds: You use a mature, specialized library (Sortable.js) for complex touch/drag interactions, but keep the data synchronization logic in htmx.","No Manual JSON Mapping: Because Sortable.js rearranges the actual input elements in the DOM, htmx's standard form submission naturally sends the correct sequence without any custom data mapping.","Visual Feedback: By targeting the list body and returning a partial, you can update \"Order\" badges or other sequence-dependent UI elements immediately after the drop.","Resilient Lifecycle: Using Hyperscript's htmx:afterSwap trigger ensures the drag-and-drop functionality continues working even after the list has been updated and replaced by htmx."]}],[{"l":"File Upload"},{"l":"Implementing File Uploads with htmx and ASP.NET Core","p":["The File Upload pattern demonstrates how to handle multi-part form data using htmx while providing real-time progress tracking. This allows for a smoother user experience compared to traditional form submissions, as the page doesn't need to refresh, and the user can see exactly how much of their file has been uploaded."]},{"l":"The Frontend: Razor & htmx","p":["In our FileUpload demo, we use hx-encoding='multipart/form-data' to ensure the browser sends the file correctly. We also include a progress element that htmx will update during the upload process.","_javascript.cshtml","Key htmx attributes used:","hx-encoding='multipart/form-data': This is required for any form that includes a file input. It tells htmx to use a FormData object for the request.","hx-post: Sends the file data to the Upload handler on the server."]},{"l":"Progress Tracking with JavaScript","p":["While htmx handles the upload, we use a small snippet of JavaScript to listen for the htmx:xhr:progress event and update our progress bar.","file-upload.js"]},{"l":"The Backend: C# PageModel","p":["On the server, the IndexModel receives the file as an IFormFile. It performs validation on the file size and extension before processing it.","Index.cshtml.cs"]},{"l":"Summary","p":["Integrating file uploads with htmx is straightforward. By setting the correct encoding and handling the htmx:xhr:progress event, you can create a modern, responsive file upload interface with minimal custom JavaScript. The server continues to handle the file logic exactly as it would in a traditional ASP.NET Core application, making it easy to implement robust validation and storage logic."]}],[{"l":"Infinite Scroll"},{"l":"Implementing Infinite Scroll with htmx and ASP.NET Core","p":["The Infinite Scroll pattern provides a seamless browsing experience where new content is automatically loaded as the user reaches the bottom of the list. This is a popular alternative to traditional pagination, often seen in social media feeds and product listings."]},{"l":"The Frontend: Razor & htmx","p":["In Index.cshtml, we start with a standard table. The initial set of rows is rendered via a partial view.","Index.cshtml","The key logic resides in the _PageResult.cshtml partial. It iterates through the contacts and specifically marks the last row of the current set with htmx attributes to trigger the next load.","_PageResult.cshtml","Key htmx attributes used:","hx-get: Requests the next page of data from the server.","hx-trigger=revealed: This is the \"magic\" attribute. It tells htmx to fire the request as soon as the element becomes visible in the viewport (i.e., when the user scrolls to it).","hx-swap=afterend: Instead of replacing the target, this appends the returned HTML after the current element, effectively extending the table rows."]},{"l":"The Backend: C# PageModel","p":["The server-side code handles the request for the next page. It tracks the current page number and returns a partial view containing the next batch of contacts.","Index.cshtml.cs"]},{"l":"Why this works well","p":["Superior UX: Users can continue reading without having to stop and click a \"Next\" button.","Efficient Loading: Data is only fetched when the user actually scrolls to it, saving bandwidth and server resources for users who only view the top of the list.","Simple Implementation: Unlike complex JavaScript solutions that require monitoring scroll events and calculating offsets, htmx handles the intersection observation automatically via the revealed trigger.","Natural Extension: Using hx-swap=afterend on the last row naturally appends the next set of rows to the existing table structure."]}],[{"l":"Keyboard Shortcuts"},{"l":"Implementing Keyboard Shortcuts with htmx and Hyperscript","p":["The Keyboard Shortcuts pattern demonstrates how to add global hotkeys to your web application using Hyperscript and htmx. This provides a \"desktop-like\" feel, allowing power users to navigate and trigger actions quickly without relying solely on the mouse."]},{"l":"1. Defining Global Shortcuts","p":["In Index.cshtml, we define the keyboard shortcuts on the main container using Hyperscript's _ attribute. We listen for keydown events from the global window object to ensure they are captured regardless of where the focus is.","Index.cshtml","Key components of the Hyperscript logic:","on keydown[...] from window: Listens for key presses globally.","[(altKey or metaKey) and shiftKey and key == '1']: Filters the event. We use both altKey(Windows) and metaKey(Mac Command key) plus shiftKey to avoid overriding default browser shortcuts.","click #btn1: Programmatically clicks the button, which then triggers its hx-post request.","focus() #search-input: For the \"S\" shortcut, we explicitly move focus to the search field, but only if the user isn't already inside another input."]},{"l":"2. Local Trigger Filters","p":["htmx also allows you to filter triggers directly on elements. In the search input, we only want to submit the search when the user presses the Enter key.","hx-trigger=keyup[key=='Enter']: This tells htmx to only perform the POST request if the keyup event was specifically for the Enter key."]},{"l":"3. The Backend: C# PageModel","p":["The server-side handlers are standard Razor Page methods. They process the request and return an HTML fragment (or a simple string) to be swapped into the target element.","Index.cshtml.cs"]},{"l":"Why this works well","p":["Declarative Shortcuts: You don't need to write complex JavaScript event listeners or manage addEventListener/ removeEventListener manually.","Unified Action Logic: By triggering a click on existing buttons, you reuse the same htmx logic for both mouse and keyboard users.","Cross-Platform Support: By checking for altKey or metaKey, you provide a consistent experience for both Windows and Mac users.","Improved Accessibility: Keyboard shortcuts make the application more efficient for power users and provide an alternative navigation method for users with motor impairments."]}],[{"l":"Dialogs with Custom htmx"},{"l":"Implementing Custom Dialogs with htmx and Hyperscript","p":["The Custom Dialog pattern shows how to build fully interactive \"Confirm\" and \"Prompt\" modals from scratch using only htmx and Hyperscript. This approach gives you total control over the styling and animation of your dialogs without requiring a heavy CSS framework like Bootstrap or UIKit for the modal logic."]},{"l":"1. Defining the Custom Modal Styles","p":["In Index.cshtml, we define basic CSS for our modal overlay and content. We use CSS transitions to handle the fade-in and slide-down animations.","Index.cshtml (Partial)"]},{"l":"2. Triggering the Modal","p":["The main page contains buttons that fetch the modal HTML from the server and inject it into a container.","Index.cshtml"]},{"l":"3. Managing the Lifecycle with Hyperscript","p":["The partial view uses Hyperscript(the _ attribute) to handle animations and cleanup. This replaces the JavaScript logic typically found in UI frameworks.","_ConfirmModal.cshtml","on load add .show to me: Triggers the CSS transition for fade-in.","on htmx:beforeOnLoad: When the user clicks \"Yes\" and the server responds successfully, we reverse the animation, wait for it to finish ( wait 300ms), and then remove me from the DOM.","The Cancel button uses Hyperscript to perform the same closing animation and cleanup without making a server request."]},{"l":"4. The Backend: C# PageModel","p":["The Index.cshtml.cs handles the requests for the modals and the actions they trigger.","Index.cshtml.cs"]},{"l":"Why this works well","p":["Zero Dependencies: You don't need a large UI library to manage your dialogs. htmx handles the content delivery, and Hyperscript handles the interactivity.","Total Design Control: Since the CSS is yours, you can make the modals look and behave exactly how you want.","Clean DOM: The remove me logic ensures that the modal is completely purged from the document once it's closed, keeping your page lightweight.","Declarative Logic: The animation and lifecycle logic are defined directly on the elements they affect, making the code much easier to follow than traditional jQuery or vanilla JS modal implementations."]}],[{"l":"Inline Validation"},{"l":"Implementing Inline Validation with htmx and ASP.NET Core","p":["The Inline Validation pattern allows you to provide immediate feedback to users as they fill out a form, without waiting for a full form submission. This is particularly useful for tasks like checking if an email address is already in use or validating complex input requirements."]},{"l":"The Frontend: Razor & htmx","p":["In the InlineValidation demo, the main form includes a partial view for the email field. This field is configured to validate itself independently.","Index.cshtml","The validation logic is defined within the _EmailField.cshtml partial. It uses htmx to trigger a validation check whenever the input changes.","_EmailField.cshtml","Key htmx attributes used:","hx-post: Sends the current value of the email field to the OnPostEmail handler. By default, for inputs, this is triggered by the change event.","hx-target=this: Ensures the server's response replaces the entire validation container (the wrapping div).","hx-swap=outerHTML: Replaces the entire container so that the error classes and messages can be updated.","hx-indicator=#ind: Shows a loading spinner while the server is validating the input."]},{"l":"The Backend: C# PageModel","p":["On the server, the IndexModel handles both the individual field validation and the final form submission. The OnPostEmail handler performs the inline check and returns the partial view.","Index.cshtml.cs"]},{"l":"Why this works well","p":["Immediate Feedback: Users know instantly if their input is invalid or if a username/email is taken, reducing frustration at the end of a long form.","Logic Reuse: The same validation logic can be used for both the inline htmx check and the final server-side form processing.","Clean Separation: The validation UI (errors, styles) is encapsulated within a partial view, making the main form template easier to read.","No Custom JavaScript: You get rich, asynchronous validation behavior using only standard ASP.NET Core tools and declarative htmx attributes."]}],[{"l":"Dialogs with UIKit"},{"l":"Implementing UIKit Dialogs with htmx and ASP.NET Core","p":["The Dialog UIKit pattern demonstrates how to integrate htmx with the UIKit CSS framework to create interactive, server-driven \"Confirm\" and \"Prompt\" dialogs. By fetching modal content on-demand and using Hyperscript to manage the UIKit lifecycle, you can create a seamless and responsive user experience."]},{"l":"1. Triggering the UIKit Modal","p":["In Index.cshtml, we use standard htmx attributes to request the modal content and inject it into a dedicated container.","Index.cshtml","hx-get=?handler=ConfirmModal: Fetches the partial view for the modal.","hx-target=#modal-container: Targets the container where the modal will be injected.","hx-swap=innerHTML: Replaces the contents of the container with the new modal HTML."]},{"l":"2. The Modal Lifecycle with Hyperscript","p":["Because UIKit modals require JavaScript to initialize and display, we use Hyperscript(the _ attribute) to handle these events declaratively.","_ConfirmModal.cshtml","on load call UIkit.modal(me).show(): Shows the modal as soon as it's injected into the DOM.","on htmx:beforeOnLoad: Hides the modal immediately after the confirmation action is successfully processed.","on hidden remove me: Automatically removes the modal element from the DOM once it's finished closing, preventing \"DOM clutter.\""]},{"l":"3. Handling Prompts and Input","p":["The Prompt pattern follows the same logic but includes a form to capture user input.","_PromptModal.cshtml","When the form is submitted, htmx sends the promptValue to the server, and the Hyperscript on the parent div handles closing the dialog."]},{"l":"4. The Backend: C# PageModel","p":["The Index.cshtml.cs file contains the handlers for returning the modals and processing the actions.","Index.cshtml.cs"]},{"l":"Why this works well","p":["Framework Flexibility: This demonstrates that htmx isn't tied to any specific CSS framework; it works just as well with UIKit as it does with Bootstrap.","Declarative Interactivity: Using Hyperscript allows you to keep your modal logic right in the HTML, avoiding the need for separate, complex JavaScript files to manage modal states.","On-Demand Loading: Modals are only loaded when needed, reducing the initial weight of the page and keeping the DOM lean.","Clean State Management: By removing the modal from the DOM on hidden, you ensure that every \"Open\" click starts with a fresh, clean state."]}],[{"l":"Lazy Loading"},{"l":"Boosting Page Performance: Lazy Loading with HTMX and ASP.NET Core Razor Pages","p":["In modern web development, speed is everything. A slow-loading dashboard can frustrate users and lead to higher bounce rates. One of the most effective techniques to improve perceived performance is Lazy Loading—deferring the loading of non-critical, heavy components until after the main page is ready.","In this post, we’ll explore how to implement lazy loading in an ASP.NET Core Razor Pages project using htmx."]},{"l":"The Scenario","p":["Imagine a \"Sales Performance Dashboard\" with two heavy components:","Sales by Region Chart: Requires complex data aggregation.","Recent Activity Feed: Fetches data from a slow external API.","Instead of making the user wait for these components to load before seeing the page, we’ll load the shell immediately and pull the data in asynchronously."]},{"l":"1. The Backend: Named Page Handlers","p":["In Razor Pages, we can use Named Handlers to return partial views independently. In our Index.cshtml.cs, we define two handlers: OnGetSalesChart and OnGetRecentActivity."]},{"l":"2. The Frontend: HTMX Magic","p":["Using htmx, we can trigger these handlers as soon as the page loads using the hx-trigger=load attribute.","In Index.cshtml, we set up containers with \"skeletons\" or loading spinners. HTMX will automatically replace these placeholders with the returned HTML once the server responds."]},{"l":"3. The Partial Views","p":["The partial views (_SalesChart.cshtml and _RecentActivity.cshtml) contain only the HTML fragment needed for those specific widgets. For example, the _SalesChart.cshtml might look like this:"]},{"l":"Why This Works","p":["Instant Feedback: The user sees the dashboard layout and navigation immediately.","Parallel Loading: Both widgets start loading at the same time, without blocking the main thread.","No Custom JavaScript: We achieved a complex asynchronous behavior using only standard ASP.NET Core patterns and a few htmx attributes."]},{"l":"Conclusion","p":["Lazy loading with htmx and Razor Pages is a powerful combination. It allows you to keep your backend logic in C# while providing the snappy, reactive experience users expect from modern web applications."]}],[{"l":"Dialogs with Bootstrap"},{"l":"Implementing Browser-Style Dialogs with htmx and Bootstrap","p":["The Dialog Browser pattern demonstrates how to replace native browser dialogs like confirm() and prompt() with rich, custom-styled Bootstrap modals using htmx. This allows you to maintain a consistent UI/UX while still leveraging server-side logic for confirmation and input processing."]},{"l":"1. Triggering the Modal","p":["In Index.cshtml, we have buttons that request the modal content from the server. Instead of the modal being hidden in the DOM, it is fetched on-demand.","Index.cshtml","hx-get=?handler=ConfirmModal: Calls the server to get the modal HTML fragment.","hx-target=#modal-container: Injects the modal into a dedicated container at the bottom of the page."]},{"l":"2. The Modal Fragment (with Hyperscript)","p":["The partial view contains the Bootstrap modal structure. We use a small amount of Hyperscript(the _ attribute) to handle the Bootstrap lifecycle (showing the modal and removing it from the DOM after it's hidden).","_ConfirmModal.cshtml","Hyperscript logic: On load, it initializes and shows the Bootstrap modal. On htmx:beforeOnLoad(when the \"Yes\" action finishes successfully), it hides the modal. On hidden.bs.modal, it cleans up by removing itself from the DOM.","hx-get=?handler=ConfirmAction: The actual action performed once the user confirms."]},{"l":"3. Handling Prompts","p":["The Prompt pattern is similar but uses a form inside the modal to capture user input.","_PromptModal.cshtml","When the form is submitted, htmx sends the promptValue to the server, updates the target on the main page, and the Hyperscript on the wrapping div handles closing the modal."]},{"l":"4. The Backend: C# PageModel","p":["The Index.cshtml.cs handles returning the partial views for the modals and the final actions triggered from within them.","Index.cshtml.cs"]},{"l":"Why this works well","p":["UX Consistency: You can style these dialogs to perfectly match your application's theme, unlike native browser dialogs.","Server-Side Templates: You don't need to write complex JavaScript to build modals or manage their state; the server provides the HTML.","Automatic Cleanup: Using Hyperscript to remove me on hidden ensures that your DOM doesn't get cluttered with orphaned modal elements.","Native Fallback: For simple cases, you can still use the built-in hx-confirm=Message attribute for a quick native browser confirmation without any extra templates."]}],[{"l":"Progress Bar"},{"l":"Implementing a Progress Bar with htmx and ASP.NET Core","p":["The Progress Bar pattern is essential for long-running tasks. It allows you to initiate a process on the server and provide real-time updates to the user without a full page reload, improving the perceived performance and user experience of your application."]},{"l":"1. Starting the Job","p":["In Index.cshtml, we have a simple button that triggers the long-running process. When clicked, it replaces the current container with the initial progress UI."]},{"l":"2. Polling for Status","p":["The server returns the _Progress.cshtml partial. This partial contains the logic to poll the server for the current job status.","_Progress.cshtml","Key htmx attributes used:","hx-get: Fetches the current progress from the JobStatus handler.","hx-trigger=every 600ms: Tells htmx to poll the server every 600 milliseconds while the status is \"Running\".","hx-trigger=done: Listens for a custom done event from the server to finalize the UI."]},{"l":"3. The Progress Bar Fragment","p":["The actual progress bar is rendered in a separate partial view, making it easy to update during polling.","_ProgressBar.cshtml"]},{"l":"4. The Backend: C# PageModel","p":["The IndexModel manages the state of the job and handles the polling requests.","Index.cshtml.cs"]},{"l":"Why this works well","p":["Server-Driven State: The server maintains the truth about the job's progress. The client simply polls and renders the current state.","Clean Completion: By using the HX-Trigger header, the server can tell htmx to stop polling and switch to a \"Completed\" view without the client needing complex logic.","Low Resource Usage: Polling occurs only while the job is active, and each request returns a tiny fragment of HTML, minimizing overhead.","Accessibility: By updating the aria-valuenow and progress bar width dynamically, the UI remains accessible to screen readers."]}],[{"l":"Tabs"},{"l":"Implementing Tabs with htmx and ASP.NET Core","p":["The Tabs pattern is a classic UI element for organizing content. With htmx, you can create a dynamic tabbing system that loads content asynchronously, reducing the initial page weight and making the interface feel snappy and modern."]},{"l":"1. The Container and Initial Load","p":["In Index.cshtml, we define a container for our tabs. We use htmx to automatically load the first tab when the page is ready.","Index.cshtml","hx-get=/Tabs/tab1: Requests the content for the first tab from the server.","hx-trigger=load delay:100ms: Automatically fires the request 100ms after the page loads.","hx-target=#tabs: Replaces the content of the div with the returned HTML."]},{"l":"2. The Tab Partial View","p":["Each tab is represented by a partial view that includes the tab navigation and the specific content for that tab. When a user clicks a different tab, htmx fetches the corresponding partial view and replaces the entire tab structure.","_tab1.cshtml","hx-get: Each button is wired to fetch its respective tab content.","class=selected: The active tab is styled differently to provide visual feedback.","Because the hx-target=#tabs was defined on the parent container in Index.cshtml, and htmx attributes are inherited, clicking any button in the partial will replace the content of the #tabs div."]},{"l":"3. The Backend: C# PageModel","p":["The server-side logic is straightforward. The IndexModel provides handlers for each tab, returning the appropriate partial view fragment.","Index.cshtml.cs"]},{"l":"Why this works well","p":["Lazy Loading: Content for secondary tabs is only fetched when requested, speeding up the initial page load for heavy content.","Simplified State: You don't need to manage \"active\" classes or \"hidden\" attributes in JavaScript. The server simply returns the HTML for the tab in its \"active\" state.","Encapsulation: Each tab's logic and view are contained within its own partial view, making the code easier to maintain and extend.","No Client-Side Routing: You get the benefits of dynamic content switching without the complexity of a client-side router or a heavy SPA framework."]}],[{"l":"Value Select"},{"l":"Implementing Cascading Selects with htmx and ASP.NET Core","p":["The Cascading Selects pattern (also known as dependent selects) is a common UI requirement where the options in one dropdown list depend on the selection made in a previous dropdown. htmx makes this incredibly simple by allowing you to fetch and swap the dependent dropdown's content asynchronously."]},{"l":"The Frontend: Razor & htmx","p":["In Index.cshtml, we have two select elements. The first select (Make) is configured to trigger an htmx request whenever its value changes.","Index.cshtml","Key htmx attributes used:","hx-get: Initiates a GET request to the Models handler when the user selects a different \"Make\".","hx-target=#models: Specifies that the HTML returned by the server (the new list of options) should be placed inside the element with the ID models.","name=make: htmx automatically includes the value of the select element in the request as a query parameter named make."]},{"l":"The Backend: C# PageModel","p":["The IndexModel manages the data for the manufacturers and their corresponding models. It uses a Dictionary to store the relationships and provides a handler to return the filtered models.","Index.cshtml.cs"]},{"l":"The Result: Partial View","p":["The _modelSelector.cshtml partial view simply renders the option elements for the model dropdown.","_modelSelector.cshtml"]},{"l":"Why this works well","p":["Cleaner Logic: You don't need to ship a massive JSON object containing every possible combination of data to the client.","Reduced Complexity: There is no need for custom JavaScript to clear, filter, or rebuild the second dropdown.","Server-Side Control: The server remains the source of truth for the available options, making it easy to integrate with a database or external API.","Instant Feedback: The UI updates immediately upon selection, providing a smooth and responsive experience for the user."]}],[{"l":"Chinook Music Store","p":["You can find Chinook Music Store running in Azure to test and explore.","Chinook Music Store on Azure."]}]]