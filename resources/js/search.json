[[{"l":"Workshop Home","p":["For the source code for the workshop, visit the htmx for Razor Pages Workshop GitHub repo.","Ask me about doing a workshop. My email is cwoodruff@live.com."]}],[{"l":"Workshop Introduction — Modern UX with htmx + ASP.NET Core Razor Pages"},{"l":"Welcome","p":["Welcome to Modern UX Without JavaScript Madness: htmx + ASP.NET Core Razor Pages.","This workshop is designed for ASP.NET Core developers who want to build fast, modern, interactive web applications without adopting a full SPA framework and without moving UI state management into the browser. Instead, we’ll use a server-first approach where the server continues to own the business rules, validation, and UI rendering—and the browser simply requests and swaps HTML fragments.","You already know Razor Pages, C#, and how to ship server-rendered applications. The goal today is to add a small, pragmatic tool— htmx—that lets you incrementally modernize UX with minimal new surface area and a maintainable architecture."]},{"l":"What is htmx?","p":["htmx is a small library that extends HTML with attributes such as:","hx-get and hx-post to make HTTP requests from buttons, links, and forms","hx-target and hx-swap to control where returned HTML is inserted","hx-trigger to control when requests fire (click, change, keyup, timers, etc.)","hx-push-url to keep browser history in sync for back/forward navigation","hx-swap-oob for out-of-band updates to multiple regions from a single response","The key difference from SPA frameworks is that htmx does not ask you to build a client-side application. It asks you to keep building HTML—and then makes it easy to update only the parts of the page that change."]},{"l":"What is hypermedia, and why does it matter?","p":["Hypermedia is the idea that the user interface itself (HTML) carries the information needed to drive the application forward—through links, forms, and server responses.","In practical terms:","The server renders UI states as HTML.","The client navigates and interacts using HTTP.","The server responds with either a full page or a fragment.","The UI evolves by swapping server-rendered HTML into known “fragment boundaries.”","This approach keeps the system simple because it aligns your UI with the web’s native strengths: HTTP semantics, URLs, caching, progressive enhancement, and straightforward debugging(you can inspect requests and HTML responses directly)."]},{"l":"The mental model for today","p":["Every lab in this workshop follows the same repeatable loop:","Identify a fragment boundary(a region of the page that should update independently).","Give it a stable wrapper element with a predictable id.","Use htmx to make an HTTP request( hx-get/ hx-post) when something happens.","Return server-rendered HTML(usually a partial) that matches the boundary.","Swap the response into the correct target ( hx-target+ hx-swap).","If you can do those five things, you can build most “modern UX” patterns without a SPA."]},{"l":"Workshop outcomes","p":["By the end of the workshop, you will be able to:","Build a “fragment-first” Razor Pages UI composed of swappable partials","Convert standard form workflows to partial updates with hx-post and hx-target","Implement real-time validation with server-side rules and hx-trigger","Build core UX patterns such as:","details views in a panel/modal","confirm + delete flows","history-aware filtering and pagination ( hx-push-url)","Create dynamic forms (add/remove rows, dependent dropdowns) with fragment endpoints","Implement long-running UX with polling and status fragments","Apply conventions that keep an htmx Razor Pages codebase production-livable"]},{"l":"How we will work today","p":["This is a hands-on workshop. You will:","Start from a working baseline project","Implement each feature step-by-step","Use DevTools frequently to inspect:","network requests","handler routes (?handler=...)","HTML fragments returned from the server","DOM swaps and target selection","If something breaks, that’s expected—debugging is part of the learning. We will use a repeatable troubleshooting checklist to unblock quickly."]},{"l":"Conventions we will follow","p":["To keep the project maintainable:","Every fragment has a single wrapper element and a stable id","outerHTML swaps replace the entire wrapper node","Handlers follow consistent naming:","OnGetList, OnPostCreate, OnPostDelete, etc.","Response rules:","full navigation returns pages","htmx requests return partial fragments","errors return a dedicated error/messages fragment","These conventions turn the labs into a blueprint you can reuse in real applications."]},{"l":"Prerequisites","p":["You should already be comfortable with:","C# and ASP.NET Core Razor Pages","basic form handling and model binding","running and debugging a .NET app locally","You will need:","a laptop with the .NET SDK and your preferred IDE installed","internet access (for library docs and reference)","browser DevTools (Chrome/Edge/Firefox)"]}],[{"l":"Installing .NET 10 and ASP.NET 10","p":["This page will instruct you how to download and install the .NET 7 SDK, including ASP.NET 10 Web API.","First, download the .NET SDK on your computer."]},{"l":"Installing the SDK for .NET 10","p":["Next, install the .NET SDK on your computer.","Next, open a terminal such as PowerShell, Command Prompt, or bash. Enter the following dotnet commands to verify that .NET 10 has been installed:","You see the .NET 10 SDK version as one of the outputs:","Congratulations! You're ready to create your first ASP.NET Web API."]},{"l":"Next steps","p":["If you need some introduction to developing .NET applications, you can follow the step-by-step tutorial or watch .NET 101 videos on YouTube."]}],[{"l":"About the Workshop"}],[{"l":"License for the Workshop","p":["The MIT License (MIT) Copyright © 2023","Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”) to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:","The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.","THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."]}],[{"l":"Foundations: Hypermedia + htmx Mental Model","p":["Goal: Establish the \"server-driven UI\" mindset and give attendees just enough htmx vocabulary to be productive in labs."]},{"l":"1. What \"Hypermedia\" Means in Web Apps"},{"l":"The Original Web Architecture","p":["The web was born as a hypermedia system. Tim Berners-Lee didn't build a \"JSON API transport layer\"—he built a document network where the server sends self-describing, interactive content.","Hypermedia= data + controls (links and forms) bundled together in a single response."]},{"l":"HTML as the Contract","p":["In a hypermedia architecture, HTML is the API contract. The server doesn't return abstract data that the client must interpret—it returns ready-to-render UI with embedded affordances.","JSON API Approach","Hypermedia Approach","Server returns { status: pending, canCancel: true }","Server returns a href=/cancelCancel/a","Client must know business rules","Server encodes business rules in the response","Client builds UI from data","Server sends ready UI","Tight coupling via shared schema","Loose coupling via HTML semantics"]},{"l":"State Transitions via Links and Forms","p":["In REST's original formulation (Fielding's dissertation), hypermedia controls drive application state. This is HATEOAS—Hypermedia As The Engine Of Application State.","Think of it like a choose-your-own-adventure book:","You're on page 47 (current state)","The page shows you options: \"Turn to page 62\" or \"Turn to page 78\"","You don't need to know the whole book's structure—just follow the links","Key insight: The server controls the workflow. The client just follows links."]},{"l":"The SPA Deviation","p":["Single-Page Applications (SPAs) broke from this model:","SPAs moved the \"application\" to the browser. The server became a dumb data pipe. This created:","Duplicated business logic (server validates, client validates)","Complex client-side state management","Hundreds of kilobytes of JavaScript","SEO and accessibility challenges"]},{"l":"2. Why htmx Exists"},{"l":"The Problem htmx Solves","p":["Modern web development often looks like this:","htmx asks: What if the browser could do this natively for any element, not just a and form?"]},{"l":"HTML Over the Wire","p":["htmx extends HTML so any element can make HTTP requests and swap the response into the DOM:","The server returns HTML fragments, not JSON:"]},{"l":"Progressive Enhancement","p":["htmx builds on progressive enhancement—the idea that your app should work without JavaScript, then get better with it.","Both versions work. The htmx version is just smoother."]},{"l":"Less JavaScript Surface Area","p":["~ 14 KB (htmx)","200-500+ KB","Build tooling","Client-side state","Framework + ecosystem","HTML attributes","htmx Approach","htmx's philosophy: The server already knows how to build HTML. Let it.","JS bundle size","Learning curve","Metric","None (server owns state)","Optional","Redux/Zustand/etc.","Typical SPA","Webpack, Vite, etc."]},{"l":"3. Core htmx Concepts"},{"l":"3.1 Requests: hx-get / hx-post / hx-put / hx-patch / hx-delete","p":["These attributes issue AJAX requests when triggered:","Default behavior:","Triggered by: click(for most elements), submit(for forms), change(for inputs)","Response swapped into: the element that made the request","Swap strategy: innerHTML"]},{"l":"3.2 Targeting: hx-target","p":["By default, htmx swaps the response into the element that triggered the request. Use hx-target to swap somewhere else:"]},{"l":"3.3 Swapping: hx-swap","p":["Controls how the response content replaces target content:","Swap modifiers(combine with any strategy):"]},{"l":"3.4 Triggers: hx-trigger","p":["Controls when requests fire:","Common trigger patterns:"]},{"l":"3.5 Indicators: hx-indicator","p":["Shows loading states during requests:"]},{"l":"3.6 History: hx-push-url","p":["Updates browser history and URL:","History restoration: When users hit back/forward, htmx automatically restores the previous page state via AJAX (using the saved URL)."]},{"l":"3.7 Out-of-Band Swaps: hx-swap-oob","p":["Update multiple parts of the page from a single response:","OOB with different swap strategies:","Use cases:","Update shopping cart count after adding item","Show toast notifications","Update multiple related data (edit user → update user list AND user count)","Refresh CSRF tokens"]},{"l":"4. Razor Pages Fit","p":["htmx and Razor Pages are a natural pairing. Razor Pages already returns HTML. htmx just asks for smaller pieces of it."]},{"l":"4.1 Handlers as Endpoints","p":["Razor Pages handlers become htmx endpoints:"]},{"l":"4.2 Partials for Fragments","p":["Create partial views that render just the fragment htmx needs:"]},{"l":"4.3 Validation + Antiforgery","p":["Antiforgery tokens: Required for POST/PUT/PATCH/DELETE requests:","Server-side validation with htmx:","Client-side validation (optional enhancement):"]},{"l":"Quick Reference Card","p":["Confirmation dialog","DELETE request","Disable during request","Example","Extra headers","Extra values to send","GET request","How to swap","htmx Attribute","hx-confirm","hx-confirm=Are you sure?","hx-delete","hx-delete=/api/remove","hx-disabled-elt","hx-disabled-elt=this","hx-get","hx-get=/api/data","hx-headers","hx-headers='{X-Custom: value}'","hx-indicator","hx-indicator=#spinner","hx-patch","hx-patch=/api/modify","hx-post","hx-post=/api/submit","hx-push-url","hx-push-url=true","hx-put","hx-put=/api/update","hx-swap","hx-swap-oob","hx-swap-oob=true","hx-swap=outerHTML","hx-target","hx-target=#results","hx-trigger","hx-trigger=click","hx-vals","hx-vals='{id: 1}'","Loading indicator","Out-of-band swap","PATCH request","POST request","Purpose","PUT request","Update browser URL","When to trigger","Where to swap response"]},{"l":"Mental Model Summary","p":["Server owns the state. Your Razor Page model is the source of truth.","Server renders the UI. Partials return ready-to-display HTML fragments.","HTML is the contract. No JSON serialization, no client-side templates.","Links and forms drive state. htmx just makes more elements behave like links and forms.","Enhance progressively. Start with working forms, add htmx for smoothness.","You're ready for the labs!"]}],[{"l":"Lab 1: Baseline Razor Pages App + \"Fragment First\""},{"l":"Overview","p":["Welcome to the first lab of the htmx + ASP.NET Core Workshop! In this lab, you will build the foundation that all subsequent labs depend upon. By the end of this lab, you will have a fully functional Razor Pages application with a clean \"Fragment First\" architecture—a design pattern that makes htmx integration seamless in later labs."]},{"l":"What is \"Fragment First\"?","p":["\"Fragment First\" is an architectural approach where you design your UI as composable HTML fragments from the very beginning, before adding any htmx interactivity. Each fragment:","Has a single responsibility(display a list, render a form, show messages)","Lives in its own partial view file","Contains a stable root element with a predictable ID(e.g., #task-list, #task-form)","This approach treats partials not as \"optimization\" or \"code organization,\" but as interfaces for future interactivity. When you later add htmx, each fragment becomes a swappable unit that the server can return independently."]},{"l":"Why This Matters","p":["Traditional server-rendered applications return full pages on every interaction. With htmx, you can return just the fragment that changed. But this only works well if your fragments are designed with clear boundaries from the start. The \"Fragment First\" pattern ensures:","Predictable targets: Every region has a known ID that htmx can target","Clean separation: Each partial handles one concern","Easy testing: You can render and verify fragments in isolation","Progressive enhancement: The app works without htmx; adding it later is additive"]},{"l":"Lab Outcomes","p":["By the end of this lab, you will have:","Outcome","Description","Working Razor Pages app","An application you can run and debug locally","Simple domain model","A \"Tasks\" domain with in-memory storage","Three fragment boundaries","List region, form region, and message region","Three partial views","_TaskList.cshtml, _TaskForm.cshtml, _Messages.cshtml","Stable target element IDs","#task-list, #task-form, #messages","This becomes the \"frame\" for all htmx work in subsequent labs."]},{"l":"Prerequisites","p":["Before starting this lab, ensure you have:",".NET 8 SDK or later installed ( download)","An IDE or editor: Visual Studio 2022, JetBrains Rider, or VS Code with C# extensions","A modern web browser with developer tools (Chrome, Edge, or Firefox)","Basic familiarity with C#, Razor Pages, and HTML"]},{"l":"Step 1: Create a New Razor Pages Project (5–8 minutes)","p":["We will create the project from scratch using the .NET CLI. This gives you full control over the project structure and ensures everyone starts from the same baseline."]},{"l":"1.1 Open Your Terminal","p":["Open a terminal or command prompt and navigate to your preferred working directory."]},{"l":"1.2 Create the Project","p":["Run the following commands to create a new Razor Pages web application:"]},{"l":"1.4 Run the Application","p":["Start the application to verify everything works:"]},{"l":"1.5 Open in Browser","p":["Open your browser and navigate to the URL shown (e.g., https://localhost:5001). You should see the default ASP.NET Core welcome page.","Keep the browser open—you will refresh frequently throughout this lab.","Tip: If you prefer, you can use dotnet watch run instead of dotnet run. This enables hot reload, automatically rebuilding and refreshing when you save changes."]},{"l":"Step 2: Create the Domain Model (10–12 minutes)","p":["Now we will establish a simple domain: Tasks. We are intentionally keeping this minimal so we can focus on UI patterns rather than data complexity."]},{"l":"Design Constraints","p":["For this workshop, we follow these constraints:","Single page focus: One page that will become highly interactive with htmx","In-memory storage: No database setup required; focus stays on UI patterns","Fully server-rendered: No htmx yet—that comes in Lab 2"]},{"l":"2.1 Create the TaskItem Model","p":["Create a new folder called Models in your project root, then create a file named TaskItem.cs:","File: Models/TaskItem.cs","Why this design:","Id: We need a way to identify individual tasks for future operations (edit, delete)","Title: The primary content users will see and interact with","IsDone: A simple status flag for visual differentiation","CreatedUtc: Useful for sorting (newest first) and displaying creation time"]},{"l":"2.2 Create the In-Memory Task Store","p":["Create a new folder called Data in your project root, then create a file named InMemoryTaskStore.cs:","File: Data/InMemoryTaskStore.cs","You can create these files manually or use your IDE's scaffolding features."]},{"l":"3.2 Create the PageModel","p":["File: Pages/Tasks/Index.cshtml.cs","Key concepts explained:","Concept","Purpose","[BindProperty]","Automatically populates Input from form data on POST","[TempData]","Stores data that survives exactly one redirect","OnGet()","Handles HTTP GET requests","OnPostCreate()","Handles HTTP POST to ?handler=Create","PRG Pattern","Post-Redirect-Get prevents duplicate form submissions"]},{"l":"3.3 Create the Razor Page (Initial Version)","p":["File: Pages/Tasks/Index.cshtml"]},{"l":"5.2 Create the Messages Partial","p":["File: Pages/Tasks/Partials/_Messages.cshtml","Critical design point: The outer div id=messages must always render, even when there is no message. This ensures htmx always has a valid target element to replace."]},{"l":"5.3 Create the Task Form Partial","p":["File: Pages/Tasks/Partials/_TaskForm.cshtml","Why pass the full IndexModel:","The form partial needs access to:","Model.Input.Title- to populate the input field (especially after validation errors)","ModelState- which is accessed via the asp-validation-for tag helper","Passing the full model keeps the partial self-contained."]},{"l":"5.4 Create the Task List Partial","p":["File: Pages/Tasks/Partials/_TaskList.cshtml","Design decision - Model type:","This partial receives IReadOnlyListTaskItem rather than the full IndexModel because:","It only needs the task data to render","It doesn't need form state or flash messages","Simpler models are easier to test and reason about"]},{"l":"Step 6: Compose the Page with Partials (8–10 minutes)","p":["Now we update the main page to use our new partials instead of inline markup."]},{"l":"6.1 Update the Index Page","p":["File: Pages/Tasks/Index.cshtml"]},{"l":"6.2 Understanding the Partial Tag Helper","p":["The partial tag helper is the recommended way to render partials in ASP.NET Core:","Attribute","Purpose","name","Path to the partial view (relative to current page folder)","model","Data to pass to the partial's @model","Path resolution:","Partials/_Messages looks for Pages/Tasks/Partials/_Messages.cshtml","The path is relative to the current page's folder ( Pages/Tasks/)"]},{"l":"6.3 Test the Refactored Application","p":["Stop and restart the application","Navigate to /Tasks","Verify the functionality:","Page displays correctly (same as before)","Creating tasks works","Validation errors display","Success messages appear","View the HTML source to confirm the fragment IDs are present"]},{"l":"Step 7: Verification Checklist (2 minutes)","p":["Before moving on to Lab 2, verify your application meets all requirements."]},{"l":"DOM Verification","p":["Open your browser's Developer Tools (F12) and confirm these elements exist:"]},{"l":"Key Takeaways"},{"l":"The \"Fragment First\" Mental Model","p":["Partials are not optimization—they are interfaces for future interactivity","The fragment root element (with id=...) is the contract—htmx will target these IDs","Each fragment has a single responsibility—messages, form, or list"]},{"l":"What Comes Next","p":["In Lab 2, you will add htmx to this foundation:","The create form will submit via hx-post and receive an updated _TaskList fragment","Only #task-list will update—no full page reload","You will add a \"Refresh list\" button using hx-get","Validation errors will swap into #task-form using response headers","The \"Fragment First\" architecture you built in this lab makes all of that possible with minimal changes to your existing code."]},{"l":"Troubleshooting"},{"l":"Common Issues and Solutions","p":["Problem","Solution","Page not found at /Tasks","Ensure Index.cshtml is in Pages/Tasks/ folder","Partial not found error","Check the path in partial name=... matches actual file location","Tasks disappear on restart","Expected behavior—data is in-memory only","Validation messages don't show","Ensure @section Scripts includes _ValidationScriptsPartial","Model binding not working","Verify [BindProperty] attribute on Input property"]},{"l":"Debug Tips","p":["View Page Source: Check that all fragment IDs render correctly","Network Tab: Verify form posts to ?handler=Create","Breakpoints: Set breakpoints in OnGet() and OnPostCreate() to trace execution"]},{"l":"Summary","p":["You have successfully completed Lab 1! You now have:","A Razor Pages application with a clean project structure","A simple domain model with in-memory storage","Three partial views representing independent UI fragments","Stable, predictable element IDs for future htmx targeting","This \"Fragment First\" architecture is your foundation for building highly interactive server-driven UIs. In Lab 2, you will see how htmx leverages these fragments to create a responsive experience without the complexity of a JavaScript framework.","Proceed to Lab 2: Partial Updates with hx-get + hx-post →"]}],[{"l":"Lab 2: Partial Updates with hx-get + hx-post"},{"l":"Overview","p":["Welcome to Lab 2! In this lab, you will transform your traditional server-rendered application into an interactive experience using htmx. You'll learn the primary htmx workflow: request a server-rendered fragment and swap it into a target.","By the end of this lab, your Tasks page will:","Submit forms without full page reloads","Update only the parts of the page that changed","Show loading indicators during requests","Handle validation errors gracefully"]},{"l":"The Core htmx Philosophy","p":["htmx follows a simple but powerful pattern:","Trigger: User action (click, submit, keyup, etc.)","Request: htmx sends an AJAX request to the server","Response: Server returns an HTML fragment (not JSON, not a full page)","Swap: htmx replaces a target element with the returned HTML","This is \"HTML over the wire\"—the server remains the source of truth for your UI, and htmx handles the transport and DOM manipulation."]},{"l":"Why This Approach?","p":["Traditional SPA","htmx Approach","Server returns JSON","Server returns HTML","Client renders UI","Server renders UI","Complex client state","Simple request/response","Heavy JavaScript","Minimal JavaScript","Separate API contracts","HTML is the contract"]},{"l":"Lab Outcomes","p":["Add a button that fetches fresh data","By the end of Lab 2, you will be able to:","Create form submits without page reload","Description","Error handling","Loading indicators","Outcome","Pass parameters","Refresh via hx-get","Show feedback during requests with hx-indicator","Submit via hx-post","Swap strategies","Target specific regions","Update only #task-list using hx-target","Use hx-swap=outerHTML to replace fragments","Use hx-vals to send additional data","Use response headers to retarget error responses"]},{"l":"Prerequisites","p":["Before starting this lab, ensure you have:","Completed Lab 1 with all verifications passing","htmx loaded in your _Layout.cshtml(we'll verify this in Step 0)","Three partials with stable IDs: #messages, #task-form, #task-list","Working OnPostCreate handler that creates tasks"]},{"l":"Step 0: Verify Prerequisites (1–2 minutes)","p":["Before adding htmx attributes, let's confirm everything is in place."]},{"l":"0.1 Verify htmx is Loaded","p":["Open Pages/Shared/_Layout.cshtml and ensure htmx is included. You should see this near the bottom of the file (before the closing /body tag):","File: Pages/Shared/_Layout.cshtml","Note: This workshop uses htmx from local files (located in wwwroot/lib/htmx/) for offline workshop environments. In production, you can use a CDN like https://unpkg.com/htmx.org@2.0.0 or install via npm."]},{"l":"0.2 Verify Fragment Structure","p":["Open your browser's Developer Tools and confirm these elements exist in the DOM:","The id attributes are essential—htmx will target these elements."]},{"l":"0.3 Verify htmx is Working","p":["Open the browser console and type:","You should see the htmx object. If you see undefined, htmx is not loaded correctly."]},{"l":"Step 1: Add hx-post to the Existing Form (5–7 minutes)","p":["Our first htmx enhancement is the simplest possible change: make the create form submit via AJAX instead of a full page reload."]},{"l":"1.1 Understanding the Change","p":["Currently, when you submit the form:","Browser sends a POST request","Server processes and redirects","Browser loads the entire new page","With htmx:","htmx intercepts the submit","htmx sends an AJAX POST request","Server returns just the updated fragment","htmx swaps that fragment into the target"]},{"l":"1.2 Update the Form Partial","p":["Edit Pages/Tasks/Partials/_TaskForm.cshtml to add htmx attributes:","File: Pages/Tasks/Partials/_TaskForm.cshtml"]},{"l":"1.3 Understanding the htmx Attributes","p":["?handler=Create","#task-list","#task-loading","Attribute","hx-indicator","hx-post","hx-swap","hx-target","outerHTML","Purpose","Put the response into the element with id=\"task-list\"","Replace the entire target element (not just its contents)","Send a POST request to this URL when form submits","Show this element as loading indicator during request","These provide progressive enhancement. If JavaScript is disabled or htmx fails to load, the form still works as a traditional form. The htmx attributes layer behavior on top without breaking the fallback.","Value","Why keep method=post and asp-page-handler?"]},{"l":"1.4 Why hx-swap=outerHTML?","p":["afterbegin","afterend","Append inside target","beforebegin","beforeend","Behavior","If we used innerHTML, htmx would try to put div id=task-list inside the existing div id=task-list, creating nested duplicates.","innerHTML","Insert after the target","Insert before the target","outerHTML","Prepend inside target","Replace target's children only","Replace the entire target element","Strategy","There are several swap strategies:","We use outerHTML because our partials return the complete wrapper element:"]},{"l":"Step 2: Convert OnPostCreate to Return Fragment for htmx (10–12 minutes)","p":["Now we need to update the server to return just the list fragment (instead of redirecting) when htmx makes the request."]},{"l":"2.1 The Strategy: Detect htmx Requests","p":["htmx sends a header with every request:","We'll check for this header to decide how to respond:","htmx request: Return the partial fragment","Normal request: Redirect (traditional PRG pattern)"]},{"l":"2.2 Add Helper Methods to the PageModel","p":["Update Pages/Tasks/Index.cshtml.cs with these additions:","File: Pages/Tasks/Index.cshtml.cs"]},{"l":"2.3 Understanding the Changes"},{"l":"The IsHtmx() Helper","p":["This checks for the HX-Request header that htmx sends with every request. This is the standard way to detect htmx requests."]},{"l":"The Fragment() Helper","p":["This creates a PartialViewResult that renders just the partial view, not the full page. The ViewDataDictionary constructor uses MetadataProvider and ModelState to preserve validation context needed for showing error messages."]},{"l":"The Success Path","p":["When htmx submits successfully, we return just the _TaskList partial. htmx swaps this into #task-list as specified by hx-target. We also send the HX-Trigger header to fire a custom event that will clear the form."]},{"l":"The Validation Error Path","p":["When validation fails:","HX-Retarget: Overrides the original hx-target; swap into #task-form instead","HX-Reswap: Specifies the swap strategy for this response","Return form: The form fragment includes validation error messages"]},{"l":"2.4 Why Retargeting?","p":["The form's hx-target is #task-list(for successful creates). But on validation failure, we want to update the form instead (to show errors). Response headers let us override the target per-response:","Scenario","Target","Response","Success","#task-list","_TaskList partial","Validation error","#task-form(retargeted)","_TaskForm partial with errors","Server error","#messages(retargeted)","_Error fragment"]},{"l":"2.5 Test the Implementation","p":["Build and run the application","Navigate to /Tasks","Open Network tab in Developer Tools","Submit a task with a valid title","Observe:","Request includes HX-Request: true header","Response is just the list HTML (not a full page)","Only #task-list updates; no page flash","Submit empty form","Form updates with validation error","List remains unchanged"]},{"l":"Step 3: Add a \"Refresh List\" Button Using hx-get (6–8 minutes)","p":["Now let's add buttons that fetch fresh data without submitting a form. This demonstrates hx-get for read operations."]},{"l":"3.1 Update the Page with Refresh Buttons","p":["Update Pages/Tasks/Index.cshtml to include the loading indicator and refresh buttons:","File: Pages/Tasks/Index.cshtml (relevant section)"]},{"l":"3.2 Understanding hx-get","p":["?handler=List","#task-list","#task-loading","Attribute","htmx replaces #task-list with the response","htmx sends GET /Tasks?handler=List","hx-get","hx-indicator","hx-swap","hx-target","outerHTML","Purpose","Put the response into #task-list","Replace the entire element","Send GET request to this URL when clicked","Server returns _TaskList partial","Show loading spinner during request","This is the canonical \"fetch and swap\" pattern:","User clicks the button","Value"]},{"l":"3.3 Understanding hx-vals","p":["Aspect","Detail","Format","JSON object as a string","Quotes","Use single quotes for the attribute, double quotes inside JSON","Result","Adds ?take=5 to the request URL (for GET) or form data (for POST)","The OnGetList(int? take) handler already accepts this parameter, so the server will limit results to 5 tasks."]},{"l":"3.4 Test the Refresh Buttons","p":["Add a few tasks using the form","Click \"Refresh All\"","Observe in Network tab:","GET request to ?handler=List","Response is just the list HTML","List updates without page reload","Click \"Top 5\"","Check Network tab: Request URL should include ?handler=Listtake=5"]},{"l":"Step 4: Add Loading Indicator Styling (5–7 minutes)","p":["The loading indicator element is already in place, but we need CSS to show/hide it properly."]},{"l":"4.1 Add CSS for the Indicator","p":["The htmx indicator styles should already be in wwwroot/css/site.css:","File: wwwroot/css/site.css (relevant section)"]},{"l":"4.2 Understanding hx-indicator","p":["Aspect","Detail","hx-indicator","CSS selector for the indicator element","htmx-indicator class","Added to indicator elements; CSS hides it by default","htmx-request class","Added to the triggering element during requests","htmx's built-in behavior:","Request starts → adds htmx-request class to the element with hx-* attributes","CSS rule .htmx-request .htmx-indicator shows the indicator","Request ends → removes htmx-request class","Indicator hides again"]},{"l":"4.3 Test Everything","p":["Test the loading indicator:","Open Network tab, enable throttling (Slow 3G)","Click refresh or submit a task","Observe the spinner appears during the request","Notice the task list becomes slightly transparent","Test validation errors:","Submit an empty form","Observe form updates with error message","List remains unchanged","Test server error:","Type \"boom\" as the task title","Submit the form","Observe error message appears in the messages area"]},{"l":"Step 5: Clear the Form After Success (6–8 minutes)","p":["Currently, after successfully adding a task, the form retains the entered value. Let's add a mechanism to clear it using htmx events."]},{"l":"5.1 The Strategy: Use HX-Trigger","p":["htmx can fire custom events that other elements listen to. We'll:","Server sends HX-Trigger: clearForm header on success","An invisible listener element catches this and refreshes the form"]},{"l":"5.2 The Handler is Already There","p":["The OnGetEmptyForm() handler is already implemented in the PageModel:"]},{"l":"5.3 Add a Listener Element to the Page","p":["The listener should already be in Pages/Tasks/Index.cshtml(near the bottom, before @section Scripts):","File: Pages/Tasks/Index.cshtml (listener section)"]},{"l":"5.4 The Event is Already Triggered","p":["The success path in OnPostCreate already includes the trigger:"]},{"l":"5.5 Understanding HX-Trigger","p":["Aspect","Detail","HX-Trigger header","Tells htmx to fire a custom event","hx-trigger=clearForm from:body","Listen for \"clearForm\" event on body","Flow","Response includes header → htmx fires event → listener catches it → makes new request","This pattern keeps your markup clean—the form itself doesn't need to know about clearing. The server controls the behavior through headers."]},{"l":"Complete File Reference"},{"l":"Index.cshtml (Complete)","p":["File: Pages/Tasks/Index.cshtml"]},{"l":"Partials Reference","p":["File: Pages/Tasks/Partials/_TaskList.cshtml","File: Pages/Tasks/Partials/_Messages.cshtml","File: Pages/Tasks/Partials/_Error.cshtml"]},{"l":"Verification Checklist","p":["Before moving to Lab 3, verify these behaviors:"]},{"l":"Form Submission","p":["Submit with valid title updates only #task-list(no page reload)","Submit with empty title shows error in #task-form(retargeted)","Submit with \"boom\" shows error in #messages(retargeted)","Form clears after successful submit","Loading spinner appears during submission"]},{"l":"Refresh Buttons","p":["\"Refresh All\" fetches and displays all tasks","\"Top 5\" fetches with take=5 parameter","Both buttons show loading indicator during request"]},{"l":"Network Verification","p":["Requests include HX-Request: true header","Responses are HTML fragments (not full pages)","Success responses include HX-Trigger: clearForm header","Error responses include HX-Retarget and HX-Reswap headers"]},{"l":"DOM Verification","p":["#task-list exists and updates correctly","#task-form exists and shows validation errors","#messages exists and shows server errors","Loading indicator shows/hides correctly"]},{"l":"Key Takeaways"},{"l":"The htmx Mental Model","p":["HTML is the response format: Server returns fragments, not JSON","Targets are CSS selectors: hx-target=#task-list finds the element by ID","Swap strategies matter: outerHTML replaces, innerHTML fills","Headers control behavior: Response headers can override client attributes"]},{"l":"Patterns You've Learned","p":["Pattern","Usage","hx-post with hx-target","Submit form, update specific region","hx-get for refresh","Fetch fresh data on demand","hx-vals","Pass parameters without forms","hx-indicator","Show loading feedback","HX-Retarget","Route responses to different targets","HX-Trigger","Fire events for secondary actions"]},{"l":"Important Implementation Details","p":["Namespace: Use RazorPagesHtmxWorkshop(not RazorHtmxWorkshop)","Fragment helper: Uses MetadataProvider and ModelState for proper validation context","Progressive enhancement: Keep traditional attributes ( method, asp-page-handler) as fallbacks","Workshop styling: Custom CSS provides dark theme with gradient backgrounds"]},{"l":"What Comes Next","p":["In Lab 3, you'll implement:","Real-time validation (\"validate as you type\")","Data annotations for validation rules","Field-level error fragments","Antiforgery token handling with htmx"]},{"l":"Troubleshooting"},{"l":"Common Issues and Solutions","p":["Add .htmx-indicator and .htmx-request rules","Add HX-Retarget and HX-Reswap","Change to outerHTML","Check console for htmx object","Check for listener div at bottom of page","Check selector matches element ID","CSS missing","Event listener missing","Form doesn't clear","Full page reloads","htmx not intercepting","htmx not loaded","Incorrect hx-target","Indicator doesn't show","Likely Cause","Nested duplicate elements","Nothing happens on submit","Problem","Retarget headers missing","Solution","Using innerHTML with wrapper","Validation errors don't show","Verify hx-post attribute is present","Wrong content swapped in"]},{"l":"Debug Tips","p":["Network Tab: Check request headers for HX-Request: true","Network Tab: Check response headers for HX-Retarget, HX-Reswap, HX-Trigger","Console: Look for htmx errors or warnings","Elements Tab: Watch DOM changes during swaps","Response Preview: Verify server returns HTML fragment, not full page"]},{"l":"Summary","p":["You have successfully completed Lab 2! Your application now:","✅ Submits forms via htmx without page reloads","✅ Updates only the affected regions of the page","✅ Shows loading indicators during requests","✅ Handles validation errors gracefully with retargeting","✅ Handles server errors with appropriate feedback","✅ Supports parameterized queries with hx-vals","✅ Clears the form after successful submission","This is the core htmx workflow that you'll use throughout your applications. In Lab 3, you'll build on this foundation to add real-time validation and more sophisticated form handling.","Proceed to Lab 3: Real-Time Validation and Form UX →"]}],[{"l":"Checkpoint: Troubleshooting + Pattern Review"},{"l":"Overview","p":["This checkpoint is a structured pause between Labs 2 and 3. Before moving to more advanced patterns like real-time validation, you need to be confident that:","Your development environment works reliably","You can debug htmx interactions using browser DevTools","You understand the common mistakes and how to fix them","You have consistent conventions for handling htmx vs. non-htmx requests","Time estimate: 10–15 minutes"]},{"l":"Checkpoint Outcomes","p":["By the end of this checkpoint, you will be able to:","Outcome","Description","Run and debug confidently","Locate the right handler for any interaction","Use DevTools effectively","Verify htmx request/response behavior","Recognize common mistakes","Identify and fix the top 5 htmx/Razor Pages integration issues","Apply consistent conventions","Standardize Page vs. Fragment response patterns"]},{"l":"Part 1: Verify Your Development Loop (5–7 minutes)","p":["Before debugging htmx-specific issues, confirm your basic development workflow is solid."]},{"l":"1.1 Run + Debug Checklist","p":["Verify each of these items:","Application runs locally (HTTPS or HTTP—either is fine)","Breakpoints hit inside handlers:","OnPostCreate","OnGetList","Hot reload or rebuild works reliably","Browser refreshes correctly after code changes","Debug Exercise:","Set a breakpoint on the first line of OnPostCreate. Submit the form and confirm:","The breakpoint is hit","You can inspect Request.Headers in the debugger","You see HX-Request: true in the headers (for htmx requests)"]},{"l":"1.2 Network Requests: What \"Good\" Looks Like","p":["Open browser DevTools → Network tab and perform these actions:"]},{"l":"For hx-post Create (Form Submission)","p":["Check","Expected Value","Request Method","POST","Request URL","Contains ?handler=Create","Request Headers","Includes HX-Request: true","Response Body","HTML fragment starting with div id=task-list","Response Status","200(success and validation error)","Example Request Headers:"]},{"l":"For hx-get Refresh (List Refresh)","p":["Check","Expected Value","Request Method","GET","Request URL","Contains ?handler=List","Request Headers","Includes HX-Request: true","Response Body","HTML fragment: div id=task-list.../div"]},{"l":"For Validation Error Responses","p":["Check","Expected Value","Response Status","200(Unprocessable Entity)","Response Headers","HX-Retarget: #task-form and HX-Reswap: outerHTML","Response Body","HTML fragment: div id=task-form.../div with error messages"]},{"l":"1.3 Inspect Returned Fragments in Elements Panel","p":["Use the Elements tab in DevTools to verify swaps are working:","Before submitting: Note the DOM node for div#task-list","After submitting: The node should be replaced (different DOM reference)","Confirm: The content inside #task-list reflects the new data","Key Insight:","htmx swaps HTML, not JSON. Debugging htmx is about inspecting HTML fragments and target elements—not parsing API payloads."]},{"l":"Part 2: Common Gotchas and Fixes","p":["This section covers the five most common htmx + Razor Pages integration mistakes. For each, you'll learn the symptoms, likely causes, and fastest diagnostic steps."]},{"l":"Gotcha A: Nothing Happens on Submit (or Button Click)","p":["Added hx-* to Index.cshtml instead of _TaskForm.cshtml","Cause","Check Console for htmx:","Clicking the button or submitting the form does nothing","Confirm you edited Pages/Tasks/Partials/_TaskForm.cshtml, not Pages/Tasks/Index.cshtml.","Console error prevented htmx from initializing","Fast Diagnostic Steps:","Fix:","htmx not loaded","If you see an object → htmx is loaded","If you see undefined→ htmx is NOT loaded","JavaScript error","Likely Causes:","No network request appears in DevTools","Open DevTools Console and type:","Page doesn't change at all","Press Ctrl+U and search for htmx. Confirm the script tag exists:","Script tag missing, blocked, or has error","Symptoms:","Verify File Location:","View Page Source:","Why It Happens","Wrong file edited"]},{"l":"Gotcha B: Request Fires, But Wrong Part Updates (or Nothing Updates)","p":["But the page doesn't update, or the wrong element updates","Cause","Check for Single ID:","Check that hx-target=#task-list matches the actual element ID (case-sensitive).","Common Mistake:","Duplicate IDs","Ensure your partial returns the complete wrapper:","Fast Diagnostic Steps:","Fix:","In Elements panel, search for #task-list. There should be exactly one element.","In Network tab, click the request and view Response. Confirm it includes:","Inspect Response Body:","Likely Causes:","Multiple elements have the same ID","Network tab shows the request completed successfully","Response contains HTML","Response fragment shape mismatch","Symptoms:","The response must include the wrapper element when using hx-swap=outerHTML.","Typo in ID or selector doesn't match DOM","Using outerHTML but response doesn't include wrapper","Verify Target Selector:","Why It Happens","Wrong hx-target selector"]},{"l":"Gotcha C: Handler Not Found / Wrong Handler Invoked","p":["?handler=Create but method is OnPostAdd","?handler=Create(POST)","?handler=Detailsid=1(GET)","?handler=List(GET)","Cause","Check HTTP Verb:","Check Request URL:","Ensure handler names align:","Fast Diagnostic Steps:","Fix:","Handler name mismatch","Handler Query","hx-get calling an OnPost... handler","hx-get→ calls OnGet... handlers","hx-post→ calls OnPost... handlers","In Network tab, verify the URL includes the correct handler:","Likely Causes:","Method doesn't exist in PageModel","Method Signature","Missing handler","Network tab shows 404 Not Found","OnGetDetails(int id)","OnGetList()","OnPostCreate()","Or: A different handler runs than expected","Or: OnGet runs when you expected OnPostCreate","Razor Pages naming convention:","Symptoms:","Verify Method Names:","Why It Happens","Wrong HTTP verb"]},{"l":"Gotcha D: Partial Path Errors (Runtime View Not Found)","p":["_TaskList.cshtml vs _Tasklist.cshtml","Both of these should use the same path pattern:","Cause","Check Case Sensitivity:","Exception message: \"The partial view '...' was not found\"","Fast Diagnostic Steps:","File in wrong folder","Fix:","If your code says:","Incorrect path in Fragment() call","Likely Causes:","On some systems, _TaskList.cshtml and _Tasklist.cshtml are different files.","Or: Wrong partial renders","Organize partials consistently:","Partial not where you think it is","Path doesn't match file location","Symptoms:","Then this file must exist:","Typo in filename","Use Consistent Paths:","Verify File Exists:","Why It Happens"]},{"l":"Gotcha E: Validation-as-You-Type Fails (403 Antiforgery or No Data Sent)","p":["Add hx-include if Needed:","Antiforgery token missing","Cause","Check Request Payload:","Ensure the form has the token and inputs include it:","Ensure your form includes the antiforgery token:","Fast Diagnostic Steps:","Fix:","Form fields not included","hx-post on input doesn't send sibling fields","If hx-post is on an input (not the form), add:","In Network tab, check if the request includes __RequestVerificationToken:","Keystroke validation returns 400 Bad Request or 403 Forbidden","Likely Causes:","POST requests require the token","Request payload is empty or missing fields","Server-side validation doesn't receive the input value","Symptoms:","Verify Token in Form:","Why It Happens"]},{"l":"Part 3: Standardize Response Conventions (Mini-Refactor)","p":["Now that you can diagnose issues, let's establish conventions that prevent them."]},{"l":"3.1 The Response Rule Set","p":["_Messages","_TaskForm","_TaskList","Content only (no wrapper needed)","div id=messages.../div","div id=task-form.../div","div id=task-list.../div","Every handler should return exactly one of these response types:","Fragment(..., model)","Full page navigation","Full wrapper element ( div id=...)","htmx","hx-swap=innerHTML","hx-swap=outerHTML","If You Use","Must Return","Non-htmx","Page() or RedirectToPage()","Partial","Partial updates","Request Type","Response Must Be","Response Type","Rule 1: A handler returns exactly one of:","Rule 2: Fragment handlers must return a wrapper with a stable ID:","Rule 3: Swap strategy must match fragment shape:","When to Use"]},{"l":"3.2 Standardize Helper Methods","p":["Ensure your PageModel includes these helpers:","File: Pages/Tasks/Index.cshtml.cs","Why These Helpers:","IsHtmx() removes magic strings scattered throughout handlers","Fragment() ensures consistent ViewData propagation (critical for validation)","Both are small enough to copy into any PageModel"]},{"l":"3.3 Standardize Handler Naming","p":["_Messages","_TaskDetails","_TaskForm(reset)","_TaskList","_TaskList(success)","_TitleValidation","Adopt these naming conventions:","Clear form","Create new task","Delete task","Field validation","Full Page","GET","Handler Name","Handler name tells you which fragment it returns","HTTP Verb","Initial page load","Load details fragment","OnGet","OnGet* for reads, OnPost* for mutations","OnGetDetails","OnGetEmptyForm","OnGetList","OnGetMessages","OnPostCreate","OnPostDelete","OnPostValidateTitle","POST","Purpose","Refresh list fragment","Refresh messages","Returns","The ?handler= value maps directly to the method suffix","The Pattern:"]},{"l":"3.4 Standardize Retarget Usage","p":["Policy: Use HX-Retarget + HX-Reswap only in two scenarios:","Scenario","Original Target","Retarget To","Why","Invalid form submit","#task-list","#task-form","Show errors in place","Server error","#messages","Route errors to message area","Everything else should use explicit hx-target in markup.","Example: Retargeting on Validation Error"]},{"l":"Part 4: Verification Exercise","p":["Complete these checks before proceeding to Lab 3."]},{"l":"Quick Verification Script (10 minutes)","p":["Click \"Refresh All\" button","Confirm:","Form fragment replaces #task-form with error message","GET request to ?handler=List","List updates without page reload","Only #task-list updates","Open DevTools → Network","Open Index.cshtml.cs","Request includes HX-Request: true","Response headers include HX-Retarget: #task-form","Response is #task-list fragment","Response is HTML fragment (not full page)","Response status is 200","Step 1: Network Verification (2 minutes)","Step 2: Validation Error Verification (2 minutes)","Step 3: Refresh Button Verification (2 minutes)","Step 4: Helper Method Verification (4 minutes)","Submit a valid task","Submit an empty form","Verify all handlers follow the response rules","Verify Fragment() helper exists","Verify IsHtmx() helper exists"]},{"l":"\"Ready to Proceed\" Checklist","p":["You are ready for Lab 3 when you can answer \"Yes\" to all of these:","I can see htmx requests in Network tab with HX-Request: true header","My Create updates only #task-list without a full page reload","Invalid Create swaps the form fragment and shows validation errors","Refresh button updates only #task-list","I can locate the handler and partial returned for any interaction","I have IsHtmx() and Fragment() helpers in my PageModel","I understand when to use HX-Retarget(and when not to)"]},{"l":"Quick Reference: Diagnostic Commands"},{"l":"Browser Console"},{"l":"Network Tab Filters","p":["Filter by XHR to see only AJAX requests","Search for handler= to find htmx requests","Check Response Headers for HX-* headers"]},{"l":"Elements Tab","p":["Search for #task-list to find target element","Watch for DOM node replacement during swaps","Check for duplicate IDs (should be exactly one)"]},{"l":"Summary","p":["This checkpoint covered:","Development loop verification: Ensure debugging and hot reload work","Network inspection: Understand what \"good\" htmx requests look like","Common gotchas: Diagnose and fix the five most frequent issues","Response conventions: Standardize how handlers respond to htmx vs. non-htmx requests","Helper methods: Establish IsHtmx() and Fragment() as standard patterns","With these foundations solid, you're ready for Lab 3: Real-Time Validation and Form UX."]},{"l":"Troubleshooting Quick Reference","p":["403 on POST","404 on handler","Add @Html.AntiForgeryToken()","Add HX-Retarget and HX-Reswap headers","Check console for htmx object","htmx not loaded","Likely Cause","Match ?handler=X to OnPost/GetX()","Missing antiforgery token","Name mismatch","Nested duplicates","Nothing happens on click","Partial not found","Quick Fix","Retarget missing","Symptom","Use outerHTML with wrapper fragments","Validation not showing","Verify file exists at expected location","Verify single ID in Elements","Wrong element updates","Wrong hx-target or duplicate ID","Wrong path","Wrong swap mode"]},{"l":"Appendix: Fragment Inventory Template","p":["Add this comment to the top of your Pages/Tasks/Index.cshtml:","This inventory prevents \"where does this fragment come from?\" confusion and documents your htmx contracts.","Proceed to Lab 3: Real-Time Validation and Form UX →"]}],[{"l":"Lab 3: Real-Time Validation and Form UX"},{"l":"Overview","p":["In this lab, you will enhance your Task form with real-time validation—providing instant feedback as users type. This is one of the most impactful UX improvements htmx enables: validation that feels responsive without sacrificing server-side authority.","By the end of this lab, your form will:","Validate input as the user types (with debouncing)","Show field-level errors without page reload","Submit with full validation and display a summary on failure","Show success messages and optionally clear the form"]},{"l":"The Key Insight","p":["Traditional forms validate only on submit. Real-time validation requires either:","Client-side JavaScript with duplicated validation rules, or","htmx with server-rendered validation fragments","We'll use htmx to keep validation rules in one place (the server) while delivering instant feedback."]},{"l":"Two Granularities of Validation","p":["Type","When","What Updates","Fragment","Micro validation","As you type (debounced)","Single field error","_TitleValidation","Full validation","On submit","Entire form with summary","_TaskForm","This dual approach gives users immediate feedback on individual fields while ensuring the full form is validated before submission."]},{"l":"Lab Outcomes","p":["Antiforgery handling","By the end of Lab 3, you will be able to:","Create tiny fragments for individual field errors","Data annotations","Description","Ensure POST requests include the token","Field-level fragments","Form reset","Full form validation","Implement hx-trigger=keyup changed delay:500ms","Optionally clear the form after successful submission","Outcome","Return entire form fragment with validation summary","Success messaging","Use [Required], [StringLength] for validation rules","Use HX-Trigger to update messages after success","Validate as you type"]},{"l":"Prerequisites","p":["Before starting this lab, ensure you have:","Completed Lab 2 with all verifications passing","Checkpoint complete with IsHtmx() and Fragment() helpers in place","Working form submission that updates #task-list on success","Working retargeting that updates #task-form on validation failure"]},{"l":"Step 1: Add Data Annotations to the Input Model (5–7 minutes)","p":["Currently, validation is handled with manual if statements in OnPostCreate. Let's replace that with data annotations—the standard .NET approach."]},{"l":"1.1 Understanding Data Annotations","p":["[EmailAddress]","[Range(1, 100)]","[Range]","[RegularExpression(@^[A-Z].*)]","[RegularExpression]","[Required(ErrorMessage = Title is required.)]","[Required]","[StringLength(60, MinimumLength = 3)]","[StringLength]","Attribute","Custom pattern","Data annotations are attributes that define validation rules declaratively:","Example","Field must have a value","Min/max length constraints","Numeric range","Purpose","Valid email format"]},{"l":"1.2 Add Required Using Statement","p":["Edit Pages/Tasks/Index.cshtml.cs and add the required namespace:","File: Pages/Tasks/Index.cshtml.cs"]},{"l":"1.3 Update the NewTaskInput Class","p":["Find the NewTaskInput class in Index.cshtml.cs and add annotations:","Update the NewTaskInput class:"]},{"l":"1.4 Understanding the Annotations","p":["Annotation","Rule","Error Message","[Required]","Cannot be null/empty","\"Title is required.\"","[StringLength(60, MinimumLength = 3)]","3–60 characters","\"Title must be 3–60 characters.\"","Why Annotations Over Manual Checks:","Single source of truth: Rules defined once, used everywhere","Automatic ModelState integration: Framework handles validation","Client-side validation support: Can generate JavaScript validation (optional)","Consistent error messages: Defined alongside the rule"]},{"l":"1.5 Update OnPostCreate to Use TryValidateModel","p":["Replace the manual validation logic in OnPostCreate with TryValidateModel:","Update OnPostCreate in Index.cshtml.cs:"]},{"l":"1.6 Understanding TryValidateModel","p":["Aspect","Detail","What it does","Evaluates all data annotations on the specified model","Returns","true if valid, false if any validation fails","Side effect","Populates ModelState with errors","Parameter 1","The model instance to validate","Parameter 2","The prefix for error keys (matches asp-for binding)","Why nameof(Input)?","This ensures error keys like Input.Title match what Razor's asp-validation-for expects. Without it, error messages might not display correctly."]},{"l":"1.7 Test the Changes","p":["Build and run the application:","Navigate to /Tasks in your browser","Try submitting with an empty title → Should see \"Title is required.\"","Try submitting with \"ab\" (2 characters) → Should see \"Title must be 3–60 characters.\"","Try submitting with a valid title → Should succeed"]},{"l":"Step 2: Create a Field-Level Validation Fragment (5–7 minutes)","p":["Now we'll create a tiny fragment specifically for the Title field's validation message. This enables real-time feedback without replacing the entire form."]},{"l":"2.1 Design the Fragment","p":["The fragment needs:","A stable wrapper with ID #title-validation","Conditional content: Show error if present, empty div if valid","Minimal size: Just the error message, nothing else"]},{"l":"2.2 Create the Validation Partial","p":["Create a new file in the Partials folder:","File: Pages/Tasks/Partials/_TitleValidation.cshtml"]},{"l":"2.3 Understanding the Fragment Design","p":["Why the wrapper always renders:","htmx needs a consistent target element. If we returned nothing when valid, htmx wouldn't know what to swap.","Why string? as the model:","This is the simplest possible model—just the error message or null. The fragment doesn't need the full form context; it only displays one piece of information."]},{"l":"Step 3: Add a Validation Handler (8–10 minutes)","p":["Now we'll create a handler specifically for validating the Title field. This handler is intentionally narrow—it validates one field and returns one fragment."]},{"l":"3.1 Organize Your Code with Regions","p":["In Index.cshtml.cs, let's add a new region for validation handlers. Find the comment section after the page handlers and add:","Add to Pages/Tasks/Index.cshtml.cs:","Place this region between your existing page handlers and the OnPostCreate method."]},{"l":"3.2 Understanding the Handler Design","p":["Why manual validation instead of ModelState?","For this micro-validation handler, explicit checks are clearer and more predictable:","Approach","Pros","Cons","Manual checks","Clear, explicit, easy to debug","Rules duplicated from annotations","ModelState","Uses existing annotations","More complex to extract single-field error","For field-level validation, manual checks are simpler. The full submit still uses annotations via TryValidateModel.","Why keep it narrow?","Keystroke validation fires frequently. Returning the entire form on each keystroke would be wasteful and could cause focus/scroll issues."]},{"l":"3.3 Alternative: Using ModelState","p":["If you prefer to use ModelState (to avoid duplicating validation logic):","This approach uses the same annotations but requires more plumbing. For workshops, the manual approach is clearer."]},{"l":"Step 4: Wire Up Real-Time Validation (10–12 minutes)","p":["Now we connect the Title input to the validation handler using htmx attributes."]},{"l":"4.1 Update the Form Partial","p":["Edit Pages/Tasks/Partials/_TaskForm.cshtml to add validation attributes and the placeholder fragment:","File: Pages/Tasks/Partials/_TaskForm.cshtml"]},{"l":"4.2 Understanding the htmx Attributes"},{"l":"On the Title Input","p":["?handler=ValidateTitle","#title-validation","Attribute","closest form","Fire after 500ms of no typing","hx-include","hx-post","hx-swap","hx-target","hx-trigger","Include form fields (especially antiforgery token)","keyup changed delay:500ms","outerHTML","Purpose","Replace the entire fragment element","Send POST to validation handler","Update only the validation fragment","Value"]},{"l":"Understanding hx-trigger","p":["Part","Meaning","keyup","Fire on key release","changed","Only if value actually changed","delay:500ms","Wait 500ms after last keystroke (debounce)","Why debounce?","Without delay, every keystroke fires a request. With 500ms delay:","User types \"Hello\" quickly → 1 request (after they pause)","User types slowly → Multiple requests (one per pause)","This balances responsiveness with server load."]},{"l":"Understanding hx-include","p":["When hx-post is on an input (not a form), htmx doesn't automatically include sibling form fields. hx-include tells htmx to serialize and include fields from the closest form.","Critical for antiforgery: Without this, the POST request won't include __RequestVerificationToken, causing a 400 or 403 error."]},{"l":"4.3 Two Validation Displays","p":["Notice we have both:","Why both?","Element","When It Shows","Source","asp-validation-for","Full form submit","ModelState from server","#title-validation","Keystroke validation","OnPostValidateTitle handler","The asp-validation-for provides fallback for non-htmx scenarios. The htmx fragment provides real-time feedback."]},{"l":"4.4 Test Real-Time Validation","p":["Navigate to /Tasks","Open Network tab in DevTools","Start typing in the Title field","Wait 500ms after typing","Observe:","POST request to ?handler=ValidateTitle","Response is the tiny #title-validation fragment","Error appears below the input (if invalid)","Continue typing to fix the error","Another request after 500ms","Fragment updates to empty (no error)"]},{"l":"Step 5: Add Success Message Handler (5–7 minutes)","p":["After successfully creating a task, we want to show a success message in the #messages area."]},{"l":"5.1 Add the Messages Handler","p":["Add to Index.cshtml.cs (in the Page Handlers region):"]},{"l":"5.2 Update OnPostCreate to Trigger the Message Event","p":["The OnPostCreate method success path should already trigger events. Verify it looks like this:","Verify this code in OnPostCreate:"]},{"l":"Step 6: Add Event Listeners to the Page (8–10 minutes)","p":["These invisible elements respond to triggered events from the server."]},{"l":"6.1 Add Listener Elements","p":["Add to Pages/Tasks/Index.cshtml (at the bottom, before @section Scripts):"]},{"l":"6.2 Understanding the Listeners","p":["?handler=Messages","#messages","Attribute","Fetch the messages fragment","Fire when showMessage event bubbles to body","How it works:","htmx dispatches a showMessage custom event on the body","hx-get","hx-swap","hx-target","hx-trigger","Listener fires its hx-get request","outerHTML","Purpose","Replace the entire element","Response swaps into #messages","Server includes HX-Trigger: showMessage in response headers","showMessage from:body","Swap into the messages region","The listener element catches the event (because of from:body)","Value"]},{"l":"6.3 The Complete Flow","p":["When a task is successfully created:","OnPostCreate succeeds → returns _TaskList+ sets HX-Trigger: showMessage,clearForm","htmx swaps #task-list with the updated list","htmx fires showMessage event → listener fetches and swaps #messages with success message","htmx fires clearForm event → listener fetches and swaps #task-form with empty form"]},{"l":"Step 7: Test the Complete Flow (5 minutes)"},{"l":"7.1 Full Integration Test","p":["Navigate to /Tasks","Add a valid task(3+ characters)","Observe:","Task appears in the list","Success message appears at the top","Form clears (ready for next entry)","Check Network tab: You should see 3 requests:","POST to ?handler=Create(returns list)","GET to ?handler=Messages(returns success message)","GET to ?handler=EmptyForm(returns clean form)"]},{"l":"7.2 Test All Scenarios","p":["Test Case","Expected Result","Type 1-2 characters, wait 500ms","Real-time error: \"Title must be at least 3 characters.\"","Type 3+ characters, wait 500ms","Real-time error disappears","Submit with empty field","Form reloads with validation error","Submit with \"ab\"","Form reloads with length error","Submit with valid title","Task added, success message shows, form clears","Type \"boom\" and submit","Error message appears in #messages"]},{"l":"Complete Code Reference","p":["Here is the complete code for all files modified in this lab."]},{"l":"Index.cshtml.cs (Complete)","p":["File: Pages/Tasks/Index.cshtml.cs"]},{"l":"_TaskForm.cshtml (Complete)","p":["File: Pages/Tasks/Partials/_TaskForm.cshtml"]},{"l":"_TitleValidation.cshtml (Complete)","p":["File: Pages/Tasks/Partials/_TitleValidation.cshtml"]},{"l":"Index.cshtml (Event Listeners Section)","p":["Add to Pages/Tasks/Index.cshtml (at the bottom, before @section Scripts):"]},{"l":"Verification Checklist","p":["Before moving to Lab 4, verify these behaviors:"]},{"l":"Real-Time Validation","p":["Typing into Title triggers a request after 500ms idle","Response swaps only #title-validation(tiny fragment)","Error appears when title is empty or too short","Error disappears when title becomes valid"]},{"l":"Full-Form Validation","p":["Submitting invalid form swaps entire #task-form","Validation summary shows at top of form (if applicable)","Field error shows next to Title input"]},{"l":"Antiforgery","p":["Keystroke validation requests include __RequestVerificationToken","Form submit requests include __RequestVerificationToken","No 400 or 403 errors on POST requests"]},{"l":"Success Flow","p":["Successful submit updates #task-list with new task","Success message appears in #messages","Form clears and is ready for next entry"]},{"l":"Network Verification","p":["Keystroke validation fires POST to ?handler=ValidateTitle","Form submit fires POST to ?handler=Create","Success triggers GET to ?handler=Messages and ?handler=EmptyForm"]},{"l":"Key Takeaways"},{"l":"Two Granularities of Feedback","p":["Granularity","Trigger","Target","Fragment","Use Case","Micro","Keystroke (debounced)","Field container","_TitleValidation","Instant feedback","Full","Form submit","Form container","_TaskForm","Complete validation"]},{"l":"Patterns You've Learned","p":["Pattern","Implementation","Debounced validation","hx-trigger=keyup changed delay:500ms","Field-level fragments","Tiny partials with stable wrapper IDs","Include form fields","hx-include=closest form for antiforgery","Event-driven updates","HX-Trigger header + listener elements","Data annotations","[Required], [StringLength] on input models"]},{"l":"When to Use Which Approach","p":["Scenario","Approach","Why","Single field feedback","Micro validation","Fast, focused, non-disruptive","Form submission","Full validation","Complete check before persist","Success actions","HX-Trigger events","Decouple concerns, clean markup","Error display","Retarget to form","Show all errors in context"]},{"l":"Troubleshooting"},{"l":"Common Issues and Solutions","p":["400/403 on validation","Add delay:500ms to trigger","Add hx-include=closest form","Always render wrapper div","Antiforgery token missing","Both asp-validation-for and htmx","Check HX-Trigger header","clearForm event not firing","Double error messages","Error doesn't clear","Form doesn't reset","Fragment returns nothing","Likely Cause","Messages don't appear","Missing delay:","Problem","showMessage event not firing","Solution","Style to hide one during typing","Validation fires on every keystroke"]},{"l":"Debug Tips","p":["Check Network tab: Verify requests fire at expected times","Check Response headers: Look for HX-Trigger, HX-Retarget","Check Console: Look for htmx errors","Inspect Elements: Verify fragment IDs match targets"]},{"l":"What Comes Next","p":["In Lab 4, you'll implement:","Details view pattern (panel or modal)","Delete with confirmation","Filtering and pagination with URL state","Better swap strategies and transitions","Proceed to Lab 4: Core UX Patterns (Modal, Confirm, History, Pagination) →"]}],[{"l":"Lab 4: Core UX Patterns (Modal, Confirm, History, Pagination)"},{"l":"Overview","p":["In this lab, you'll implement the core UX patterns that make htmx-powered applications feel polished and professional. These patterns are the building blocks of real-world interactive applications:","Details View: Load content into a Bootstrap modal without page reload","Delete with Confirmation: Safe destructive actions with user confirmation","Filtering and Pagination: URL-driven state that supports browser back/forward","Smooth Transitions: Visual polish with CSS transitions","By the end of this lab, your Tasks application will feel like a modern single-page application—but with the simplicity of server-rendered HTML."]},{"l":"The Key Insight","p":["These patterns share a common theme: the server remains in control. Instead of building client-side state machines, you let htmx handle the transport while the server decides what HTML to return.","Traditional SPA","htmx Approach","Client manages state","Server renders fragments","Router handles URLs","hx-push-url syncs URL","Modal logic in JS","Modal body loaded via hx-get","Pagination component","Links with hx-get+ hx-push-url"]},{"l":"Lab Outcomes","p":["Add CSS transitions for smooth visual feedback","By the end of Lab 4, you will be able to:","Delete with confirm","Description","Details pattern","Filter the task list with URL state preserved","Filtering","Load task details into a Bootstrap modal","Navigate pages with back/forward support","Outcome","Pagination","Swap strategies","Transitions","Understand when to use different swap approaches","URL state","Use hx-confirm for safe destructive actions","Use hx-push-url to make URLs bookmarkable"]},{"l":"Prerequisites","p":["Before starting this lab, ensure you have:","Completed Lab 3 with all verifications passing","Working validation(both real-time and full-form)","Success messages and form reset working via HX-Trigger","Fragment helpers( IsHtmx() and Fragment()) in place"]},{"l":"Step 1: Create the Task List View Model (5–7 minutes)","p":["To support filtering and pagination, we need a richer view model than just a list of tasks."]},{"l":"1.1 Create the TaskListVm Class","p":["File: Models/TaskListVm.cs (create new file)"]},{"l":"1.2 Understanding the View Model","p":["bool(computed)","Current filter query","Current page number (1-based)","HasNextPage","HasPreviousPage","int","int(computed)","IReadOnlyListTaskItem","Items","Items per page","Page","PageSize","Property","Purpose","Query","string?","The current page of tasks","This view model encapsulates all the information needed to render a paginated, filtered list with navigation controls.","Total","Total number of items (after filtering)","Total number of pages","TotalPages","Type","Whether next page exists","Whether previous page exists"]},{"l":"Step 2: Add Data Store Methods for Details and Delete (5 minutes)"},{"l":"2.1 Add Find and Delete Methods","p":["File: Data/InMemoryTaskStore.cs (add these methods)","These methods enable the Details and Delete features we'll implement."]},{"l":"Step 3: Update the PageModel for Filtering and Pagination (12–15 minutes)","p":["We'll update the PageModel to support URL-based filtering and pagination using model binding."]},{"l":"3.1 Add Query Parameter Properties","p":["File: Pages/Tasks/Index.cshtml.cs (add these properties at the top of the class)"]},{"l":"3.2 Understanding BindProperty(SupportsGet = true)","p":["Aspect","Detail","What it does","Binds query string parameters to properties for GET requests","Without it","Only POST requests bind to properties","With it","Both GET and POST requests bind to properties","Parameter name","Matches the property name exactly (case-sensitive)","This means:","URL: /Tasks?Q=testPageNum=2Size=10","Automatically binds to: Q = test, PageNum = 2, Size = 10"]},{"l":"3.3 Update OnGet Handler","p":["File: Pages/Tasks/Index.cshtml.cs (replace OnGet method)","Key Changes:","Filtering: Applies Q parameter to filter tasks","Pagination: Uses PageNum and Size to paginate results","htmx support: Returns fragment for htmx requests, full page otherwise","Validation: Ensures PageNum is at least 1 and Size is between 1-50"]},{"l":"3.4 Add OnGetList Handler","p":["File: Pages/Tasks/Index.cshtml.cs (add this handler)","This handler provides a dedicated endpoint for fetching paginated/filtered lists via htmx."]},{"l":"Step 4: Add Details Handler (5 minutes)"},{"l":"4.1 Create OnGetDetails Handler","p":["File: Pages/Tasks/Index.cshtml.cs (add this handler)","This handler fetches a single task and returns a modal fragment."]},{"l":"Step 5: Add Delete Handler (8–10 minutes)"},{"l":"5.1 Create OnPostDelete Handler","p":["File: Pages/Tasks/Index.cshtml.cs (add this handler)","Key Features:","State preservation: Applies the same filter/pagination as before delete","Page adjustment: If deleting the last item on a page, moves back to previous page","Error handling: Returns error message if task not found","Success messaging: Triggers showMessage event"]},{"l":"Step 6: Update OnPostCreate to Return View Model (5 minutes)","p":["The Create handler needs to return the same view model structure as the list.","File: Pages/Tasks/Index.cshtml.cs (update the success path in OnPostCreate)","This ensures the list updates correctly after adding a task, preserving filter/pagination state."]},{"l":"Step 7: Create the Task Details Modal Fragment (8–10 minutes)"},{"l":"7.1 Create the Details Partial","p":["File: Pages/Tasks/Partials/_TaskDetails.cshtml (create new file)"]},{"l":"7.2 Understanding the Modal Pattern","p":["Key Aspects:","Complete modal structure: The fragment includes the entire Bootstrap modal (not just the body)","Swapped into container: Gets inserted into #task-modal-container","JavaScript trigger: A script shows the modal after it's loaded","Null handling: Gracefully displays a message if task not found"]},{"l":"Step 8: Update the Task List Fragment (15–18 minutes)","p":["Now we'll update the task list to use the view model and include pagination controls."]},{"l":"8.1 Rewrite _TaskList.cshtml","p":["File: Pages/Tasks/Partials/_TaskList.cshtml (complete rewrite)"]},{"l":"8.2 Understanding Key Patterns"},{"l":"Details Button","p":["Attribute","Value","Purpose","hx-get","?handler=Detailsid=...","Fetch task details","hx-target","#task-modal-container","Inject modal into container","hx-indicator","#task-loading","Show loading spinner"]},{"l":"Delete Button","p":["?handler=Delete","'{id: ..., Q: ..., ...}'","#task-list","Attribute","Browser confirmation","Delete this task?...","hx-confirm","hx-post","hx-target","hx-vals","Pass ID + preserve state","POST to delete handler","Purpose","These ensure the delete handler can return a list with the same filter/pagination state. Without them, the list would reset to page 1 with no filter.","Update the list","Value","Why hx-vals includes Q, PageNum, Size:"]},{"l":"Pagination Links","p":["Attribute","Value","Purpose","hx-get","?Q=...PageNum=...Size=...","Fetch specific page","hx-push-url","true","Update browser URL","URL State Preservation:","Q=@(Model.Query ?? ) preserves the current filter","PageNum=@i sets the new page","Size=@Model.PageSize maintains page size"]},{"l":"Step 9: Update the Main Page for Filtering and Modal (12–15 minutes)"},{"l":"9.1 Update Index.cshtml","p":["File: Pages/Tasks/Index.cshtml (update the list section)","Find the section where the task list is rendered and update it to:"]},{"l":"9.2 Understanding Key Elements"},{"l":"Filter Input","p":["?","Attribute","Debounced keystroke","GET to current page (calls OnGet)","hx-get","hx-push-url","hx-trigger","keyup changed delay:400ms","name","Parameter name for binding","Purpose","Q","true","Update browser URL","Using ? calls the default OnGet handler, which checks IsHtmx() and returns a fragment. This is simpler and more consistent.","Value","Why hx-get=? instead of ?handler=List:"]},{"l":"Modal Container","p":["This empty div serves as the injection point for the modal. The modal is dynamically loaded and removed."]},{"l":"Modal Show Script","p":["How it works:","htmx fires htmx:afterOnLoad after swapping content","Script checks if the target was #task-modal-container","If yes, finds the #task-modal element (now in the DOM)","Creates a Bootstrap Modal instance and shows it"]},{"l":"Step 10: Add CSS Transitions (Optional, 5–7 minutes)","p":["Add visual polish with CSS transitions."]},{"l":"10.1 Add Transition Styles","p":["File: wwwroot/css/site.css (add these styles)"]},{"l":"10.2 Understanding htmx CSS Classes","p":["htmx adds these classes during the swap lifecycle:","Class","When Applied","Duration","htmx-request","Request is in flight","Until response","htmx-swapping","Old content being removed","Brief","htmx-settling","New content settling in","htmx-added","New elements just added"]},{"l":"Complete Code Reference"},{"l":"Index.cshtml.cs (Complete PageModel)","p":["File: Pages/Tasks/Index.cshtml.cs"]},{"l":"InMemoryTaskStore.cs (Updated)","p":["File: Data/InMemoryTaskStore.cs"]},{"l":"Verification Checklist","p":["Before moving to Lab 5, verify these behaviors:"]},{"l":"Details Pattern","p":["Clicking \"Details\" opens a Bootstrap modal","Modal displays task information correctly","Closing modal works (X button or backdrop click)","Modal shows \"Task not found\" for invalid IDs"]},{"l":"Delete Pattern","p":["Clicking \"Delete\" shows browser confirmation dialog","Confirming deletes task and updates list","Canceling keeps task in list","Success message appears after delete","List refreshes with correct pagination after delete"]},{"l":"Filtering","p":["Typing in filter updates list after 400ms","Filter is applied (shows matching tasks only)","URL updates with Q parameter (?Q=test)","\"Clear filter\" link removes filter and resets URL","Filter persists when navigating pages"]},{"l":"Pagination","p":["Pagination controls appear when tasks > page size (5)","Clicking page number updates list","URL updates with PageNum parameter","Browser back/forward navigates through history","Filter is preserved when changing pages"]},{"l":"State Preservation","p":["Deleting a task preserves filter and pagination","Adding a task preserves filter and pagination","Refreshing the page loads with correct filter/pagination"]},{"l":"Transitions","p":["List fades during swap (if CSS added)","Loading indicator appears during requests","Buttons are disabled during their request"]},{"l":"Key Takeaways"},{"l":"Patterns Summary","p":["CSS + htmx classes","Delete","Details Modal","Filter","hx-get, hx-target=#task-modal-container","hx-get=?, hx-push-url","hx-post, hx-confirm, hx-vals","hx-push-url on links","Key Attributes","Live search with URL state","Load content into modal","Navigable, bookmarkable pages","Pagination","Pattern","Purpose","Safe destructive actions","Transitions","Visual polish"]},{"l":"URL State Philosophy","p":["The key insight of this lab is that URLs should reflect application state:","Filter query → ?Q=test","Current page → ?PageNum=2","Page size → ?Size=10","This enables:","Bookmarking: Users save filtered/paginated views","Sharing: Send a link to a specific view","History: Back/forward buttons work correctly","Progressive enhancement: Non-JS users get the same functionality"]},{"l":"Model Binding with BindProperty","p":["This is a cleaner alternative to manually reading query parameters:","Without BindProperty","With BindProperty","Request.Query[q]","Q property","Manual parsing","Automatic binding","Easy to forget","Declarative"]},{"l":"State Preservation Pattern","p":["When an action might change the list (create, delete), preserve the current state:","This ensures users don't lose their place when performing actions."]},{"l":"Troubleshooting"},{"l":"Common Issues","p":["Add data-bs-dismiss=modal to close button","Add hx-push-url=true","Back button doesn't work","Binding case mismatch","Check Bootstrap is loaded, verify script","Ensure OnGet uses Q, PageNum, Size","Filter resets on delete","Include Q in delete button's hx-vals","Likely Cause","Missing Bootstrap JS or script","Missing data-bs-dismiss","Missing hx-push-url","Missing Q in hx-vals","Modal doesn't close","Modal doesn't open","OnGet doesn't handle params","Page shows wrong items","Problem","Solution","URL doesn't update","Use exact names: Q, PageNum, Size"]},{"l":"Debug Tips","p":["Check Network tab: Verify request URL includes all parameters","Check Response: Confirm fragment structure is correct","Check URL bar: Verify hx-push-url is updating the URL","Check Console: Look for htmx or Bootstrap errors","Test back/forward: Ensure page loads with correct state","Inspect htmx:afterOnLoad: Verify modal script is firing"]},{"l":"What Comes Next","p":["In Lab 5, you'll implement:","Dynamic form rows (Add/Remove tag inputs)","Dependent dropdowns (Category → Subcategory)","Long-running operations with polling","Out-of-band swaps for global updates","Proceed to Lab 5: Dynamic Forms + Long-Running UX (Polling) →"]}],[{"l":"Checkpoint: Make It Production-Livable"},{"l":"Overview","p":["This checkpoint focuses on establishing maintainability patterns and conventions for htmx + Razor Pages applications. Before moving to more advanced patterns, it's essential to align on \"how to structure this\" so that your codebase remains clean, debuggable, and scalable.","Production-livable means your code is:","Discoverable: Anyone can find the right file quickly","Predictable: Patterns are consistent across features","Debuggable: You can trace from request to response easily","Maintainable: Adding new features follows established conventions"]},{"l":"Time Estimate","p":["10–15 minutes"]},{"l":"Checkpoint Outcomes","p":["By the end of this checkpoint, you will have:","Outcome","Description","Folder conventions","Clear structure for partials and handlers","Handler naming","Predictable, discoverable method names","Response rules","Consistent patterns for fragments vs pages vs errors","Reusable helpers","Standard utilities you can copy to real projects","Fragment inventory","Documentation of your htmx contracts"]},{"l":"Part 1: Folder Conventions for Partials and Handlers (5–7 minutes)","p":["A well-organized folder structure makes it easy to find and maintain code. The key principle: co-locate fragments with the features that use them."]},{"l":"1.1 Recommended Production Structure"},{"l":"1.2 Why This Structure Works","p":["Aspect","Benefit","Co-location","Partials live next to the page that owns them","Discoverability","File paths mirror the mental model","Ownership","Fragment boundaries are \"owned\" by a specific feature","Scalability","Easy to add new features following the same pattern"]},{"l":"1.3 Understanding Fragment Boundaries","p":["_Error.cshtml","_Messages.cshtml","_TaskDetails.cshtml","_TaskForm.cshtml","_TaskList.cshtml","_TitleValidation.cshtml","(targets #messages)","#messages","#task-details","#task-form","#task-list","#title-validation","Create/edit form","Detail panel/modal content","Each partial represents a fragment boundary—a swappable region of the UI:","Error display","Field-level validation","Fragment ID","List of tasks (paginated, filtered)","Partial","Purpose","Success/error messages"]},{"l":"1.4 Handler Placement Rule","p":["Keep htmx handlers on the same PageModel when:","They return fragments used only by that page (most common case)","The fragments are feature-specific","Promote to dedicated endpoints when:","Multiple pages share the same fragment endpoint (true reuse)","The fragment becomes an independent \"resource\" with its own lifecycle","You need different authorization or caching rules","Example: When to Extract"]},{"l":"1.5 Verify Your Structure","p":["Checklist:","Partials folder exists under each feature folder","Each partial has a clear, single responsibility","Partial file names start with underscore (_)","Fragment IDs are documented (even as comments)"]},{"l":"Part 2: Consistent Handler Naming (5–7 minutes)","p":["Handler names should be self-documenting. Anyone reading the code should know what a handler returns just from its name."]},{"l":"2.1 Handler Naming Convention","p":["Use resource + intent naming aligned with HTTP verbs:"]},{"l":"GET Fragment Handlers","p":["Handler","Returns","Purpose","OnGetList(...)","_TaskList","Fetch the list fragment","OnGetDetails(int id)","_TaskDetails","Fetch details for one item","OnGetMessages()","_Messages","Fetch messages fragment","OnGetEmptyForm()","_TaskForm(reset)","Fetch a clean form"]},{"l":"POST Action Handlers","p":["Handler","Returns","Purpose","OnPostCreate()","_TaskList(success)","Create new item","OnPostDelete(int id)","_TaskList","Delete an item","OnPostValidateTitle()","_TitleValidation","Validate a single field","OnPostUpdate(int id)","_TaskList or _TaskDetails","Update an item"]},{"l":"2.2 The Naming Rule","p":["If the handler returns a fragment, its name should tell you which fragment it serves."]},{"l":"2.3 URL Convention in Markup","p":["Keep URLs consistent and predictable:"]},{"l":"2.4 Why This Matters for Debugging","p":["With consistent naming, debugging becomes trivial:","Open Network tab in DevTools","See request URL: ?handler=Detailsid=42","Know immediately: Look in OnGetDetails(int id)","Find the partial: Handler returns _TaskDetails","No guessing, no searching—the URL maps directly to a method name."]},{"l":"2.5 Verify Your Naming","p":["Checklist:","Handler names follow verb + resource pattern","GET handlers start with OnGet","POST handlers start with OnPost","Names indicate which fragment they return","URL patterns in markup match handler names exactly"]},{"l":"Part 3: Basic Response Rules (5–7 minutes)","p":["These rules prevent \"htmx spaghetti\"—random swaps, inconsistent fragments, and mixed concerns."]},{"l":"3.1 Response Rule 1: Full Navigation Returns Pages","p":["When: The interaction is classic navigation (non-htmx request)","Return: Page() or RedirectToPage()","Examples:"]},{"l":"3.2 Response Rule 2: Fragment Interactions Return Partials","p":["When: The request is htmx ( HX-Request: true)","Return: A PartialViewResult containing only the fragment","Examples:"]},{"l":"3.3 The Fragment Contract","p":["Critical Rule: If you use hx-swap=outerHTML, the fragment must include its wrapper with the correct ID.","Fragment","Must Return","_TaskList","div id=task-list.../div","_TaskForm","div id=task-form.../div","_Messages","div id=messages.../div","_TaskDetails","div id=task-details.../div","Why This Matters:","If the fragment doesn't include the wrapper, htmx won't find the element to swap."]},{"l":"3.4 Response Rule 3: Errors Return Dedicated Fragments","p":["Have a consistent error handling strategy:"]},{"l":"Validation Errors"},{"l":"Not Found Errors"},{"l":"Server Errors"},{"l":"3.5 Response Rules Summary Table","p":["200","302","Fragment(_Error, msg)","Fragment(_Messages, msg)","Fragment(_TaskForm, this)","Fragment(..., model)","Full page","htmx not found","htmx server error","htmx success","htmx validation error","Initial page load","Non-htmx form submit","Original hx-target","Page()","RedirectToPage()","Response","Retarget to #messages","Retarget to #task-form","Scenario","Status","Target"]},{"l":"3.6 When to Use Retargeting","p":["Use HX-Retarget + HX-Reswap only in these cases:","Invalid submit: Form targets the list, but on validation failure you need to update the form instead","Error routing: Route errors to #messages from any interaction","Everything else should use explicit hx-target in markup.","Why limit retargeting?","Keeps behavior predictable","Makes debugging easier (what you see in markup is what happens)","Prevents \"action at a distance\" bugs"]},{"l":"Part 4: Standardize PageModel Helpers (3–5 minutes)","p":["Every PageModel that serves htmx requests should have these helpers:"]},{"l":"4.1 The IsHtmx() Helper","p":["Why it matters:","Removes magic strings from handler code","Makes branching explicit and readable","Easy to test (can mock header in tests)"]},{"l":"4.2 The Fragment() Helper","p":["Why it matters:","Ensures ViewData (including ModelState) flows to partials","Consistent return type across all fragment handlers","Cleaner than repeating new PartialViewResult { ... } everywhere"]},{"l":"4.3 Required Using Statement","p":["Add this to your PageModel:"]},{"l":"4.4 Complete Helper Section","p":["Here's how the helpers look in context:"]},{"l":"4.5 Verify Your Helpers","p":["Checklist:","IsHtmx() helper exists in PageModel","Fragment() helper exists in PageModel","using Microsoft.AspNetCore.Mvc.ViewFeatures; is added","Handlers use IsHtmx() instead of checking headers directly","Handlers use Fragment() instead of constructing PartialViewResult manually"]},{"l":"Part 5: Fragment Inventory (3–5 minutes)","p":["Document your fragment contracts to prevent accidental ID drift and broken swaps."]},{"l":"5.1 Create a Fragment Inventory","p":["Add a comment block to your page's Razor file or PageModel:","Option A: In Index.cshtml","Option B: In Index.cshtml.cs"]},{"l":"5.2 Why Document Fragment Contracts?","p":["Benefit","Description","Prevents ID drift","Team knows which IDs are \"reserved\"","Debugging aid","Quick reference for which handler returns what","Onboarding","New developers understand the page structure","Maintenance","Safely rename/refactor with full visibility"]},{"l":"5.3 URL State Policy (If Using Filtering/Pagination)","p":["Document your URL state policy:"]},{"l":"Part 6: Quick Reference Card"},{"l":"Response Decision Tree"},{"l":"Handler Naming Quick Reference","p":["Pattern","Example","Returns","OnGet{Resource}","OnGetList()","_TaskList","OnGetDetails(int id)","_TaskDetails","OnPost{Action}","OnPostCreate()","_TaskList(success)","OnPostDelete(int id)","OnPostValidate{Field}","OnPostValidateTitle()","_TitleValidation"]},{"l":"Status Codes Quick Reference","p":["Status","Meaning","Use Case","200","OK","Successful response","302","Redirect","Non-htmx form submit"]},{"l":"htmx Headers Quick Reference","p":["Header","Direction","Purpose","HX-Request","Request","Identifies htmx request","HX-Trigger","Response","Fire client-side events","HX-Retarget","Override hx-target","HX-Reswap","Override hx-swap","HX-Push-Url","Update browser URL"]},{"l":"Verification Checklist","p":["Before moving to Lab 5, verify these items:"]},{"l":"Folder Structure","p":["Partials folder exists under Pages/Tasks/","Each fragment has a dedicated partial file","Partial names start with underscore"]},{"l":"Handler Naming","p":["GET handlers follow OnGet{Resource} pattern","POST handlers follow OnPost{Action} pattern","Handler names indicate which fragment they return"]},{"l":"Response Rules","p":["Non-htmx requests return Page() or RedirectToPage()","htmx requests return Fragment()","Error responses retarget to #messages"]},{"l":"Helpers","p":["IsHtmx() helper is implemented","Fragment() helper is implemented","Handlers use helpers consistently"]},{"l":"Documentation","p":["Fragment inventory exists (comment or doc)","Fragment IDs are documented","Handler-to-fragment mapping is clear"]},{"l":"\"Ready to Proceed\" Gate","p":["Attendees should be able to answer \"yes\" to all of these:","I can locate fragments: I know exactly where to find _TaskList.cshtml and other partials","I can trace requests: Given a URL like ?handler=Detailsid=42, I can find the handler immediately","I understand response rules: I know when to return Page() vs Fragment() vs retarget","I have consistent helpers: IsHtmx() and Fragment() are in my PageModel","I can debug swaps: I can verify fragment boundaries in DevTools"]},{"l":"Key Takeaways"},{"l":"The Core Principle","p":["htmx + Razor Pages is about discipline, not complexity.","The patterns are simple:","Fragment boundaries with stable IDs","Handlers that return partials","Consistent naming and response rules","The discipline is maintaining these patterns consistently across your codebase."]},{"l":"What Makes Code \"Production-Livable\"","p":["Attribute","How to Achieve It","Discoverable","Co-locate partials with features, use clear naming","Predictable","Follow response rules, name handlers consistently","Debuggable","URL matches handler, fragment matches ID","Maintainable","Document contracts, use helpers"]},{"l":"The Anti-Patterns to Avoid","p":["Anti-Pattern","Better Approach","Can't find handlers","Clear response rules","Explicit fragment boundaries","Fragment inventory","Hard to debug","Hard to refactor","ID drift, broken swaps","Inconsistent naming","Magic strings","Mixed response types","Random hx-targets","Undocumented fragments","Unpredictable behavior","Use helpers","Verb + resource pattern","Why It's Bad"]},{"l":"What Comes Next","p":["In Lab 5, you'll implement:","Dynamic form rows (Add/Remove tag inputs)","Dependent dropdowns (Category → Subcategory)","Long-running operations with polling","Out-of-band swaps for global updates","With your codebase now \"production-livable,\" these advanced patterns will be easier to implement and maintain.","Proceed to Lab 5: Dynamic Forms + Long-Running UX (Polling) →"]}],[{"l":"Lab 5: Dynamic Forms + Long-Running UX (Polling)"},{"l":"Overview","p":["This lab covers two high-value scenarios that traditionally require significant JavaScript but can be elegantly solved with htmx:","Dynamic UI Composition: Add/remove form rows, dependent dropdowns","Long-Running Operations: Progress updates via polling without WebSockets","These patterns appear constantly in real applications—order line items, tag management, category filters, background job status, file uploads with progress. By the end of this lab, you'll have reusable blueprints for all of them."]},{"l":"The Key Insight","p":["Add form row","Both patterns share a common theme: the server controls the UI state.","Custom event system","Dependent dropdown","htmx Approach","hx-swap-oob for out-of-band swaps","hx-trigger=every 1s+ status endpoint","JavaScript clones DOM, manages indexes","JavaScript fetches JSON, builds options","Long-running job","Multiple updates","Scenario","Server renders new row fragment","Server renders options fragment","Traditional Approach","WebSocket or complex polling library"]},{"l":"Lab Outcomes","p":["By the end of Lab 5, you will be able to:","Outcome","Description","Add/Remove rows","Dynamic sub-collections (tags, line items) via fragment endpoints","Dependent dropdowns","Cascading selects (Category → Subcategory)","Polling","Long-running operations with hx-trigger=every Xs","Out-of-band swaps","Update multiple page regions from a single response","Conditional polling","Start/stop polling based on job status","Enhanced details view","Display all task properties including tags and categories"]},{"l":"Prerequisites","p":["Before starting this lab, ensure you have:","Completed Lab 4 with all verifications passing","Production-livable conventions in place (checkpoint complete)","Working CRUD operations for Tasks","Fragment helpers( IsHtmx() and Fragment()) ready"]},{"l":"Pattern 1: Dynamic Form Rows (Add/Remove Tags) (15–20 minutes)","p":["This pattern lets users add and remove items in a sub-collection—like tags on a task, line items on an order, or attendees on an event."]},{"l":"1.1 The Design","p":["User Flow:","User sees a task form with a \"Tags\" section","User clicks \"Add Tag\" → new empty tag input appears","User can remove any tag by clicking its \"Remove\" button (client-side, no server round-trip)","On form submit, all tags are collected and saved","Architecture:","Tags are rendered as a list of inputs inside a #tags-container","\"Add Tag\" button fetches a new tag row fragment from server","Each tag row has a \"Remove\" button that removes itself client-side using htmx's hx-on attribute","Tags use simple name binding ( Input.Tags) - ASP.NET Core handles multiple values automatically"]},{"l":"1.2 Update the TaskItem Model","p":["First, add Tag support to the TaskItem model:","File: Models/TaskItem.cs"]},{"l":"1.3 Update the Input Model","p":["Extend NewTaskInput to support tags:","File: Pages/Tasks/Index.cshtml.cs (update NewTaskInput class)"]},{"l":"1.4 Create the Tag Row Fragment","p":["This fragment renders a single tag input with a client-side remove button:","File: Pages/Tasks/Partials/_TagRow.cshtml","Key Points:","Simplified binding: All tag inputs use the same name=Input.Tags, and ASP.NET Core automatically binds them to a List","Client-side removal: Uses hx-on:click=this.closest('.tag-row').remove() to remove the row without a server call","No index tracking needed: The server doesn't need to manage indexes"]},{"l":"1.5 Create the Tags Container Fragment","p":["This fragment wraps all tag rows and includes the \"Add Tag\" button:","File: Pages/Tasks/Partials/_TagsContainer.cshtml"]},{"l":"1.6 Add the Tag Handler","p":["File: Pages/Tasks/Index.cshtml.cs (add to #region Dynamic Tags)"]},{"l":"1.7 Update InMemoryTaskStore","p":["Update the Add method to accept tags, category, and subcategory:","File: Data/InMemoryTaskStore.cs"]},{"l":"1.8 Update OnPostCreate to Handle Tags","p":["File: Pages/Tasks/Index.cshtml.cs (update OnPostCreate method)"]},{"l":"Pattern 2: Dependent Dropdowns (Category → Subcategory) (10–15 minutes)","p":["Dependent dropdowns (cascading selects) update one dropdown based on another's selection—like Category → Subcategory, Country → City, or Make → Model."]},{"l":"2.1 The Design","p":["User Flow:","User selects a Category from the first dropdown","Subcategory dropdown updates with relevant options","User selects a Subcategory","Form can be submitted with both values","Architecture:","Category dropdown has hx-get that fetches subcategory options on change","Subcategory dropdown is wrapped in a swappable container (#subcategory-container)","Server returns the subcategory select fragment"]},{"l":"2.2 Create Sample Data","p":["For this example, we'll use simple in-memory data:","File: Data/CategoryData.cs (create new file)"]},{"l":"2.3 Create the Subcategory Fragment","p":["File: Pages/Tasks/Partials/_SubcategorySelect.cshtml","Key Fix:","Uses disabled=@(Model.Options.Count == 0) instead of the old conditional string approach","Uses selected=@(option == Model.Selected) for proper boolean attribute binding"]},{"l":"2.4 Add the Subcategory Handler","p":["File: Pages/Tasks/Index.cshtml.cs (add to #region Dependent Dropdowns)","Important: Uses [FromQuery(Name = Input.Category)] to bind the correct query parameter."]},{"l":"2.5 Add Category/Subcategory to the Form","p":["File: Pages/Tasks/Partials/_TaskForm.cshtml (add before Tags section)"]},{"l":"2.6 Test Dependent Dropdowns","p":["Navigate to /Tasks","Select a Category(e.g., \"Work\")","Observe: Subcategory dropdown updates with relevant options","Select a different Category","Observe: Subcategory options change accordingly","Clear Category(select placeholder)","Observe: Subcategory becomes disabled"]},{"l":"Pattern 3: Enhanced Task Details Modal (10 minutes)","p":["Now that we have tags and categories, let's update the details modal to show ALL task information."]},{"l":"3.1 Update the TaskDetails Partial","p":["File: Pages/Tasks/Partials/_TaskDetails.cshtml","New Features:","Shows Category and Subcategory","Displays Tags as badges","Shows Task Status (Done/Open)","Displays Task ID and Created timestamp","Better visual organization with grouped fields"]},{"l":"Pattern 4: Long-Running Operations with Polling (15–20 minutes)","p":["Some operations take time—file processing, report generation, external API calls. Instead of making users wait on a loading spinner, you can show progress updates via polling."]},{"l":"4.1 Create a Simple Job Simulation","p":["For the workshop, we'll simulate a background job with in-memory state:","File: Data/JobSimulator.cs (create new file)"]},{"l":"4.2 Create the Job Status Fragment","p":["File: Pages/Tasks/Partials/_JobStatus.cshtml"]},{"l":"4.3 Create the OOB Job Status Fragment","p":["For job completion, we want to update both the job status AND show a message:","File: Pages/Tasks/Partials/_JobStatusWithOob.cshtml"]},{"l":"4.4 Add the Job Handlers","p":["File: Pages/Tasks/Index.cshtml.cs (add to #region Long-Running Jobs)"]},{"l":"4.5 Add Job Status to the Page","p":["File: Pages/Tasks/Index.cshtml (add section for job demo)","Add the using statement at the top:"]},{"l":"Complete Handler Inventory (Lab 5)","p":["_JobStatus","_JobStatus or _JobStatusWithOob","_JobStatus(null)","_SubcategorySelect","_TagRow","(Not used - removal client-side)","Add new tag input","Empty","GET","Handler","OnGetAddTag","OnGetJobStatus","OnGetRemoveTag","OnGetResetJob","OnGetSubcategories","OnPostStartJob","Poll job progress","POST","Purpose","Reset job UI","Returns","Start background job","Update subcategory dropdown","Verb"]},{"l":"Verification Checklist","p":["Before completing the workshop, verify these behaviors:"]},{"l":"Dynamic Tags","p":["\"Add Tag\" button appends new tag input","Each tag has a working remove button (client-side, instant)","Multiple tags can be added","Tags are included when form submits","Form reset clears all tags","Flash message shows tag count on success"]},{"l":"Dependent Dropdowns","p":["Selecting a category updates subcategory options","Changing category updates subcategory again","Clearing category disables subcategory","Selected values persist on validation failure","Category and subcategory are saved with task"]},{"l":"Enhanced Task Details","p":["Details modal shows Category and Subcategory","Details modal shows all Tags as badges","Details modal shows Task Status (Done/Open)","Details modal shows Task ID and Created timestamp"]},{"l":"Polling","p":["Starting job shows progress card","Progress updates every second","Network tab shows polling requests","Polling stops when job completes","Success/failure state displays correctly"]},{"l":"OOB Swaps","p":["Job completion updates both job card and messages","Single network response contains both fragments","Messages area shows appropriate alert"]},{"l":"Key Fixes and Improvements in Lab 5"},{"l":"1. Simplified Tag Implementation","p":["Before (documented):","Required server-side removal handler","Complex index tracking with hx-vals","Individual IDs for each tag row","After (actual code):","Client-side removal with hx-on:click","Simple name=Input.Tags binding","No index management needed"]},{"l":"2. Fixed Category/Subcategory Attributes","p":["Before (old syntax):","After (proper Razor):"]},{"l":"3. Enhanced Task Details Modal","p":["Now shows complete task information:","Category and Subcategory","Tags (with badge styling)","Status (Done/Open badge)","Task ID","Created timestamp"]},{"l":"4. Proper Parameter Binding","p":["Uses [FromQuery(Name = Input.Category)] for subcategory handler to correctly bind the parameter from the htmx request."]},{"l":"Key Takeaways"},{"l":"Pattern Summary","p":["Pattern","Key Technique","When to Use","Add/Remove Rows","hx-swap=beforeend+ client-side removal","Dynamic sub-collections","Dependent Dropdowns","hx-get on change + proper parameter binding","Cascading selections","Polling","hx-trigger=every Xs in fragment","Long-running operations","OOB Swaps","hx-swap-oob=true on additional fragments","Multi-region updates"]},{"l":"The Server Controls Everything","p":["In all four patterns, the server decides:","What HTML to render(the fragments)","Whether to continue polling(by including/excluding trigger)","What else to update(via OOB fragments)","Validation and business logic(tags cleanup, category relationships)","This is the power of hypermedia: the server remains in control of application state."]},{"l":"Troubleshooting"},{"l":"Common Issues","p":["Add hx-on:click attribute","Details missing info","Dropdown doesn't update","Ensure target element exists","Likely Cause","Missing hx-on:click","Missing parameter binding","Old partial version","OOB swap fails","Polling doesn't stop","Problem","Remove button doesn't work","Remove trigger when done","Solution","Tags not binding","Target ID doesn't exist","Trigger in completed state","Update _TaskDetails.cshtml","Use [FromQuery] attribute","Use name=Input.Tags(no index)","Wrong name attribute"]},{"l":"Workshop Wrap-Up","p":["Congratulations! You've completed Lab 5 and mastered:","Dynamic forms with add/remove functionality","Dependent dropdowns with cascading selection","Long-running operations with polling","Out-of-band swaps for multi-region updates","Enhanced UI patterns showing complete data models","Next Steps:","Apply these patterns to your real projects","Explore htmx extensions (SSE, WebSockets)","Read the htmx documentation at htmx.org","Join the htmx community","Thank you for completing the workshop!"]}],[{"l":"Capstone: Hardening + Take-Home Extensions"},{"l":"Overview","p":["This capstone session transforms your workshop labs into a repeatable blueprint you can apply to real projects. We'll consolidate what you've learned, establish conventions you can document for your team, and explore advanced extensions you can implement on your own."]},{"l":"Session Goals","p":["Goal","Description","Consolidate","Clean up code, remove duplication, standardize patterns","Document","Create a convention checklist for your team","Extend","Explore advanced patterns (inline edit, optimistic UI, SSE)","Adopt","Understand how to introduce htmx to existing applications"]},{"l":"Time Estimate","p":["15–20 minutes (core) + take-home extensions"]},{"l":"Part 1: Clean-Up Pass (5–7 minutes)","p":["Before leaving the workshop, let's ensure your codebase is well-organized and ready to serve as a reference."]},{"l":"1.1 Fragment Consolidation","p":["_Error.cshtml","_JobStatus.cshtml","_JobStatusWithOob.cshtml","_Messages.cshtml","_SubcategorySelect.cshtml","_TagRow.cshtml","_TagsContainer.cshtml","_TaskDetails.cshtml","_TaskForm.cshtml","_TaskList.cshtml","_TitleValidation.cshtml","(int, string)","(IReadOnlyListstring, string?)","(JobStatus, string, string)","Create/edit form","Current Fragment Inventory:","Dependent dropdown","Detail view (panel/modal)","Field-level validation","Fragment","Generic error display","IndexModel","Job status + OOB message","JobStatus?","List with pagination","Liststring","Model","Polling job status","Purpose","Review your Pages/Tasks/Partials/ folder and ensure each fragment has a single responsibility:","Single tag input","string","string?","Success/error messages","Tags section with add button","TaskItem?","TaskListVm"]},{"l":"1.2 Remove Duplication","p":["Check for repeated patterns:","Check for repeated fragment returns:"]},{"l":"1.3 Tighten Target IDs","p":["Ensure every swappable region has:","A stable, unique ID in the fragment","Consistent naming(#task-list, not #taskList or #list)","Documentation(comment in the partial)","Example: Add ID documentation to each fragment:"]},{"l":"1.4 Handler Organization","p":["Group handlers logically in your PageModel:"]},{"l":"1.5 Clean-Up Checklist","p":["Before moving on, verify:","All fragments have consistent ID documentation","All handlers use IsHtmx() helper","All fragment returns use Fragment() helper","Handlers are grouped logically","No duplicate code patterns exist","Unused code/comments are removed"]},{"l":"Part 2: Convention Checklist (5–7 minutes)","p":["Create a reference document your team can use when building htmx + Razor Pages features."]},{"l":"2.1 The Complete Convention Checklist","p":["Save this as HTMX_CONVENTIONS.md in your project root:"]},{"l":"Response Rules"},{"l":"When to return what","p":["Scenario","Response","Initial page load","Page()","Non-htmx form submit","RedirectToPage()","htmx success","Fragment(..., model)","htmx validation error","Fragment(_Form, this)+ retarget","htmx not found","Fragment(_Messages, msg)+ retarget","htmx server error","Fragment(_Error, msg)+ retarget"]},{"l":"Status Codes","p":["200: Success","302: Redirect (non-htmx)"]},{"l":"Swap Strategies","p":["Strategy","Use When","outerHTML","Fragment includes its wrapper (default)","innerHTML","Swapping content inside a container","beforeend","Appending to a list","afterbegin","Prepending to a list","delete","Removing an element","none","Side effects only (triggers)"]},{"l":"htmx Attributes Quick Reference"},{"l":"Requests","p":["hx-get=?handler=List- GET request","hx-post=?handler=Create- POST request","hx-vals='{key: value}'- Include additional values"]},{"l":"Targeting","p":["hx-target=#element-id- Where to swap","hx-swap=outerHTML- How to swap"]},{"l":"Triggers","p":["hx-trigger=click- On click (default for buttons)","hx-trigger=change- On change (default for select)","hx-trigger=keyup changed delay:500ms- Debounced input","hx-trigger=every 1s- Polling"]},{"l":"Extras","p":["hx-confirm=Are you sure?- Confirmation dialog","hx-indicator=#loading- Show during request","hx-include=closest form- Include form data","hx-push-url=true- Update browser URL"]},{"l":"Response Headers"},{"l":"From Server","p":["HX-Trigger: eventName- Fire client event","HX-Retarget: #selector- Override hx-target","HX-Reswap: innerHTML- Override hx-swap","HX-Push-Url: /path- Update browser URL"]},{"l":"Validation Pattern"},{"l":"Field-level (keyup)"},{"l":"Form-level (submit)","p":["On validation failure: retarget to form."]},{"l":"Error Handling Pattern"},{"l":"Polling Pattern"},{"l":"OOB Swap Pattern","p":["hx-get=\"?handler=List\" → OnGetList() → Fragment(\"_ List\", data) hx-post=\"?handler=Create\" → OnPostCreate() → Fragment(\"_ List\", data)"]},{"l":"Part 3: Optional Extensions (Take-Home)","p":["These extensions build on the patterns you've learned. Implement them to deepen your understanding."]},{"l":"Extension 1: Inline Edit Row (Intermediate)","p":["Goal: Click an item to edit it inline, save without leaving the list.","Design:","Each list item has an \"Edit\" button","Clicking Edit replaces the row with an edit form","Save replaces the form with the updated row","Cancel restores the original row","Implementation:","File: Pages/Tasks/Partials/_TaskRow.cshtml","File: Pages/Tasks/Partials/_TaskRowEdit.cshtml","Handlers:","Add to InMemoryTaskStore:"]},{"l":"Extension 2: Optimistic UI with Disabled Buttons (Beginner)","p":["Goal: Disable buttons and show loading state during requests to prevent double-submits.","Design:","Button shows spinner and disables during request","Uses htmx CSS classes ( htmx-request)","No JavaScript required","Implementation:","CSS (add to site.css):","Button with Loading State:","Delete Button with Loading:"]},{"l":"Extension 3: SSE (Server-Sent Events) for Live Updates (Advanced)","p":["Goal: Push updates to the browser without polling.","Design:","Server sends events when data changes","htmx SSE extension listens for events","Events trigger fragment refreshes","Implementation:","1. Add htmx SSE Extension:","2. Create SSE Endpoint:","File: Pages/Tasks/TaskEvents.cshtml.cs","3. Connect UI to SSE:","4. Trigger Changes:"]},{"l":"Extension 4: Authorization Edge Cases (Intermediate)","p":["Goal: Handle authorization properly with htmx requests.","Design:","Return appropriate status codes for auth failures","Redirect to login for unauthenticated users","Show permission errors for unauthorized actions","Implementation:","Custom Authorization Filter:","Permission Check Helper:","Handle Expired Sessions:"]},{"l":"Extension 5: Keyboard Shortcuts (Beginner)","p":["Goal: Add keyboard navigation for power users.","Implementation:","Add to UI:"]},{"l":"Part 4: Final Recap and Adoption Path"},{"l":"4.1 The Mental Model","p":["Core Concept: Server-Driven UI","The Flow:","User action triggers htmx request","Server handler processes request","Razor partial renders HTML fragment","htmx swaps fragment into DOM","Browser displays updated UI","What Makes This Powerful:","Server controls all logic and state","HTML is the API contract","No JSON parsing or DOM manipulation","Progressive enhancement built-in","Works with any backend"]},{"l":"4.2 Adoption Path for Real Applications","p":["Phase 1: Start Small (Week 1)","Phase 2: Establish Conventions (Week 2)","Phase 3: Expand Gradually (Weeks 3-4)","Phase 4: Advanced Patterns (Ongoing)"]},{"l":"4.3 Common Adoption Questions","p":["Q: Can htmx work alongside existing JavaScript?","A: Yes. htmx is just a library that processes HTML attributes. Your existing JavaScript continues to work. You can mix approaches—use htmx for server-rendered fragments and JavaScript for purely client-side interactions.","Q: What about forms that need client-side validation?","A: Use both! Client-side validation for immediate feedback, server-side for authority. htmx doesn't prevent you from using required, pattern, or JavaScript validation.","Q: How do I handle offline scenarios?","A: htmx works best with connectivity. For offline support, consider:","Service workers for caching","Local storage for queuing actions","Progressive enhancement (forms work without JS)","Q: What about SEO?","A: Server-rendered HTML is SEO-friendly by default. Use hx-push-url to update URLs for shareable/indexable state. Initial page loads render full content.","Q: How do I test htmx interactions?","A: Test at two levels:","Unit tests: Test handlers return correct fragments","Integration tests: Use browser automation (Playwright, Selenium) to verify swaps"]},{"l":"4.4 Resources for Continued Learning","p":["Official Resources:","htmx.org - Documentation and examples","htmx.org/essays - Philosophy and patterns","GitHub: bigskysoftware/htmx - Source and issues","Community:","htmx Discord server","r/htmx on Reddit","#htmx on Twitter/X","Books and Courses:","\"Hypermedia Systems\" by Carson Gross (htmx creator)","Various YouTube tutorials and conference talks","ASP.NET Core Specific:","Microsoft Docs: Razor Pages","htmx + ASP.NET Core blog posts","This workshop materials!"]},{"l":"Verification Checklist (Final)","p":["Before leaving the workshop, confirm:"]},{"l":"Code Quality","p":["All fragments have documented IDs","All handlers use consistent helpers","No duplicate patterns exist","Code is organized logically"]},{"l":"Documentation","p":["Convention checklist is saved","Quick reference card is printed/saved","Fragment inventory is complete"]},{"l":"Understanding","p":["I can explain the htmx mental model","I know when to use each swap strategy","I understand the response rules","I can debug htmx interactions"]},{"l":"Next Steps","p":["I've identified a feature to convert","I have resources bookmarked","I know where to get help"]},{"l":"Congratulations!","p":["You've completed the htmx + ASP.NET Core Workshop!"]},{"l":"What You've Learned","p":["Lab","Key Skills","Lab 1","Fragment boundaries, partial views, stable IDs","Lab 2","hx-get, hx-post, targeting, swapping, retargeting","Lab 3","Real-time validation, debouncing, antiforgery","Lab 4","Modals, confirm dialogs, URL state, pagination","Lab 5","Dynamic forms, dependent selects, polling, OOB swaps","Capstone","Conventions, hardening, advanced extensions"]},{"l":"The htmx Philosophy","p":["\"HTML is the contract. The server is in control. Complexity is optional.\"","Take this approach back to your projects. Start small, establish conventions, and expand gradually."]},{"l":"Stay Connected","p":["Share your htmx projects and questions:","Workshop feedback: [your contact]","htmx community: discord.gg/htmx","Twitter/X: #htmx","Thank you for attending!"]},{"l":"Appendix: Complete Handler Reference","p":["_JobStatus","_Messages","_SubcategorySelect","_TagRow","_TaskDetails","_TaskForm","_TaskList","_TaskRow","_TaskRowEdit","_TitleValidation","(empty)","(Page)","Add tag input","Cancel edit (extension)","Create item","Delete item","Edit mode (extension)","Fetch messages","Fetch/refresh list","For reference, here's a complete handler inventory from all labs:","Fragment","GET","Handler","Initial page load","Load item details","OnGet","OnGetAddTag","OnGetCancelEdit","OnGetDetails","OnGetEditRow","OnGetEmptyForm","OnGetJobStatus","OnGetList","OnGetMessages","OnGetRemoveTag","OnGetResetJob","OnGetSubcategories","OnPostCreate","OnPostDelete","OnPostReset","OnPostStartJob","OnPostUpdateRow","OnPostValidateTitle","Poll job progress","POST","Purpose","Remove tag","Reset all tasks","Reset form","Reset job UI","Start background job","Update dropdown","Update item (extension)","Validate field","Verb"]}],[{"l":"Workshop UI Examples","p":["Active Search","Animations","Bulk Update","Click To Edit","Click To Load","Delete Row","Demonstrates a job-runner like progress bar","Demonstrates bulk updating of multiple rows of data","Demonstrates clicking to load more rows in a table","Demonstrates how to create keyboard shortcuts for htmx enabled elements","Demonstrates how to display and select tabs using HATEOAS principles","Demonstrates how to do inline field validation","Demonstrates how to edit rows in a table","Demonstrates how to lazy load content","Demonstrates how to upload a file via ajax with a progress bar","Demonstrates how to use htmx with the Sortable.js plugin to implement drag-and-drop reordering","Demonstrates infinite scrolling of a page","Demonstrates inline editing of a data object","Demonstrates making the values of a select dependent on another select","Demonstrates modal dialogs from scratch","Demonstrates modal dialogs using UIKit","Demonstrates row deletion in a table","Demonstrates the active search box pattern","Demonstrates the prompt and confirm dialogs using Bootstrap","Demonstrates various animation techniques","Description","Dialogs - Bootstrap","Dialogs - Custom","Dialogs - UIKit","Drag & Drop with Sorting","Edit Row","File Upload","htmx examples GitHub repo","htmx examples on Azure","Infinite Scroll","Inline Validation","Keyboard Shortcuts","Lazy Loading","Pattern","Progress Bar","Tabs--","Value Select","You can find all exaples running in Azure to test and explore."]}],[{"l":"Active Search"},{"l":"Implementing Active Search with htmx and ASP.NET Core","p":["The Active Search pattern is one of the most popular use cases for htmx, providing a \"search-as-you-type\" experience without the complexity of a full-blown JavaScript framework. Here's a look at how it's implemented in our ActiveSearch demo."]},{"l":"The Frontend: Razor & htmx","p":["In Index.cshtml, we define a search input that triggers a request to the server as the user types.","Key htmx attributes used:","hx-post: Tells htmx to make a POST request to the Search handler on the current Page.","hx-trigger: Specifies when to fire the request. We use keyup changed delay:500ms so it only fires 500ms after the user stops typing, avoiding excessive server hits.","hx-target: Tells htmx where to put the returned HTML (in this case, our table body).","hx-indicator: Shows a loading spinner while the request is in flight."]},{"l":"The Backend: C# PageModel","p":["On the server side in Index.cshtml.cs, we handle the search request. The OnPostSearch method fetches data from an external API (REST Countries) based on the input and returns a partial view."]},{"l":"The Result: Partial View","p":["Finally, _searchResult.cshtml renders just the rows needed for the table:","This approach keeps the logic simple, the state on the server, and the UI fast and responsive."]}],[{"l":"Bulk Update"},{"l":"Implementing Bulk Updates with htmx and ASP.NET Core","p":["The Bulk Update pattern demonstrates how to handle multiple record updates efficiently using htmx. This approach allows users to select several items from a list and perform an action on all of them at once, with the UI updating dynamically to reflect the changes."]},{"l":"The Frontend: Razor & htmx","p":["In Index.cshtml, we have a set of buttons and a table wrapped in a form. The buttons use hx-include to pull in the selected checkboxes.","Key htmx attributes used:","hx-put: Sends a PUT request to the specified page handler ( OnPutActivate or OnPutDeactivate).","hx-include: Ensures that the values from the #checked-contacts form (specifically the checked checkboxes named ids) are included in the request, even though the buttons are outside the form.","hx-target: Specifies that the returned HTML should replace the content of the tbody with the ID tbody."]},{"l":"The Backend: C# PageModel","p":["The Index.cshtml.cs file handles the bulk update logic. It receives an array of IDs from the checked checkboxes and updates the corresponding contacts via a service."]},{"l":"The Result: Partial View","p":["The _tbody.cshtml partial view renders the table rows. It also applies CSS classes to rows that were just updated to provide visual feedback.","By using hx-include, we decouple the action buttons from the form structure, and by returning a partial view, we update only the necessary part of the page, making the application feel much more responsive."]}],[{"l":"Click to Edit"},{"l":"Implementing Click-to-Edit with htmx and ASP.NET Core","p":["The Click-to-Edit pattern is a sleek way to provide inline editing capabilities. Instead of redirecting to a separate edit page, htmx allows you to swap the display view with an edit form in-place, and then swap back once the update is complete."]},{"l":"1. The Display State","p":["Initially, we show the contact information. The container is configured to handle the swap when an inner element triggers an htmx request.","_DisplayContactForm.cshtml","hx-target=this: Tells htmx to replace the current div with the response.","hx-swap=outerHTML: Ensures the entire div is replaced, not just its content.","hx-get: Requests the edit form from the EditContact handler."]},{"l":"2. The Edit State","p":["When the \"Click To Edit\" button is pressed, the server returns a partial view containing the form.","_EditContactForm.cshtml","hx-put: Submits the form data to the ReplaceContact handler.","The \"Cancel\" button uses hx-get to fetch the display version again, discarding changes."]},{"l":"3. The Backend: C# PageModel","p":["The Index.cshtml.cs file manages the transitions between these states by returning the appropriate partial views.","Index.cshtml.cs"]},{"l":"Summary","p":["This pattern provides a very \"app-like\" feel. By swapping small fragments of HTML, you avoid full page reloads and maintain the user's scroll position and context, all while keeping your logic cleanly separated in Razor Pages and C#."]}],[{"l":"Click to Load"},{"l":"Implementing Click-to-Load with htmx and ASP.NET Core","p":["The Click-to-Load pattern is a great alternative to traditional pagination or infinite scroll. It allows users to load more data only when they explicitly request it, keeping the initial page load light while providing a smooth way to browse through larger datasets."]},{"l":"The Frontend: Razor & htmx","p":["In Index.cshtml, we start with an initial set of data and a \"Load More\" button (contained within a partial view).","Index.cshtml","The magic happens in the partial view. When the user clicks the button, htmx fetches the next page and replaces the entire row containing the button with the new data and a new button for the subsequent page.","_ClickToLoadButton.cshtml","Key htmx attributes used:","hx-get: Requests the next page of results from the server.","hx-target=#replaceMe: Targets the specific table row that currently holds the button.","hx-swap=outerHTML: Replaces the target row with the new rows and the next \"Load More\" button."]},{"l":"The Backend: C# PageModel","p":["The IndexModel handles the logic for fetching paged data. It uses ViewData to keep track of the current page number so the partial view knows what page to request next.","Index.cshtml.cs"]},{"l":"Why this works well","p":["Reduced Initial Payload: You only send the first few records to the browser.","Server-Side State: The server dictates what the next \"page\" is by providing the URL in the new \"Load More\" button.","Seamless Integration: New rows are appended to the table naturally, maintaining the user's scroll position while extending the list.","Simplicity: No complex JavaScript state management is required to track offsets or append elements to the DOM."]}],[{"l":"Delete Row"},{"l":"Implementing Row Deletion with htmx and ASP.NET Core","p":["The Delete Row pattern is a common requirement in data-driven applications. Using htmx, you can remove a record from the database and concurrently update the UI by removing the corresponding row from a table—all without a full page reload."]},{"l":"The Frontend: Razor & htmx","p":["In Index.cshtml, we set up a table where the tbody is configured to handle the deletion logic for all its child rows.","Index.cshtml","The individual rows are rendered via a partial view. Each row contains a \"Delete\" button that triggers the htmx request.","_TableRow.cshtml","Key htmx attributes used:","hx-confirm: Automatically triggers a browser confirmation dialog before the request is sent.","hx-post: Sends a POST request to the Contact handler with the specific contact's ID.","hx-target=closest tr: (Defined on the parent tbody) Tells htmx to target the table row containing the clicked button.","hx-swap=outerHTML swap:1s: Replaces the entire row with the server response (which is empty in this case). The swap:1s allows for a CSS transition effect (like a fade-out) before the element is finally removed from the DOM.","hx-include=closest form: Ensures the Anti-Forgery Token from the form is included in the POST request."]},{"l":"The Backend: C# PageModel","p":["The IndexModel handles the deletion request. When the record is successfully deleted from the service, it returns an OkResult. Since the response body is empty, htmx simply removes the target element (the row) from the page.","Index.cshtml.cs"]},{"l":"Why this works well","p":["Declarative UI: You define the confirmation and targeting logic once on the container ( tbody), making the individual row templates cleaner.","Visual Feedback: By using swap:1s, you can use CSS transitions to provide a smooth removal animation, making the UI feel more polished.","Low Overhead: The server only needs to return a simple 200 OK status, minimizing bandwidth and processing time.","Security: The use of [ValidateAntiForgeryToken] and hx-include=closest form ensures that the deletion requests are protected against CSRF attacks."]}],[{"l":"Edit Row"},{"l":"Implementing Row Editing with htmx and ASP.NET Core","p":["The Edit Row pattern allows users to edit individual rows in a table without leaving the page or opening a modal. By leveraging htmx, we can swap a static table row for an editable version and then swap it back once the update is complete."]},{"l":"1. The Table Structure","p":["In Index.cshtml, we define a table where the tbody is configured to handle the swap target for any htmx request originating from its children.","Index.cshtml","hx-target=closest tr: This tells htmx that the result of any request within this body should target the nearest table row.","hx-swap=outerHTML: Replaces the entire tr element with the response from the server."]},{"l":"2. The Read-Only Row","p":["Initially, each contact is rendered using a read-only partial view. The \"Edit\" button triggers a GET request to fetch the editable version of that specific row.","_TableRow.cshtml"]},{"l":"3. The Editable Row","p":["When the \"Edit\" button is clicked, the server returns the _EditRow.cshtml partial. This row contains input fields and action buttons.","_EditRow.cshtml","hx-include=closest tr: Ensures that the values of the input fields in the current row are included in the PUT request.","The \"Cancel\" button simply fetches the read-only row again, discarding any unsaved changes."]},{"l":"4. The Backend: C# PageModel","p":["The IndexModel handles the transitions between states. It provides handlers for entering edit mode, canceling/viewing, and performing the update.","Index.cshtml.cs"]},{"l":"Summary","p":["This pattern keeps the user in the flow of their data. By targeting only the \"closest tr\", htmx makes it easy to manage row-level state without complex JavaScript selectors or managing a global state object. The transition between \"view\" and \"edit\" modes is seamless and extremely responsive."]}],[{"l":"Drag & Drop with Sorting"},{"l":"Implementing Drag-and-Drop Sorting with htmx and ASP.NET Core","p":["The Drag-and-Drop Sortable pattern demonstrates how to integrate a specialized JavaScript library like Sortable.js with htmx to create a reorderable list that syncs its state with the server automatically. This provides a highly intuitive UI for managing sequences or priorities."]},{"l":"1. The Frontend: Sortable.js & htmx","p":["In Index.cshtml, we wrap our list in a form. We use a small Hyperscript block to initialize the Sortable.js library and bridge its events over to htmx.","Index.cshtml","Key htmx and Hyperscript attributes:","hx-post=?handler=Reorder: Specifies the server endpoint to receive the new order.","hx-trigger=end: htmx waits for a custom DOM event named end to be fired before sending the request.","on load or htmx:afterSwap: Hyperscript ensures that Sortable.js is initialized (or re-initialized after a swap) on the list element.","onEnd: function() { htmx.trigger(...) }: Inside the Sortable.js configuration, we manually trigger the end event that htmx is listening for whenever a drag operation finishes."]},{"l":"2. The Item List Partial","p":["The list items contain a hidden input. When Sortable.js reorders the DOM elements, these inputs move with them. When htmx submits the form, it sends these IDs in their new order.","_ItemList.cshtml"]},{"l":"3. The Backend: C# PageModel","p":["The server receives an array of integers representing the IDs in the order they appear in the DOM. It updates the database (or in-memory store) accordingly and returns the updated list fragment.","Index.cshtml.cs"]},{"l":"Why this works well","p":["Best of Both Worlds: You use a mature, specialized library (Sortable.js) for complex touch/drag interactions, but keep the data synchronization logic in htmx.","No Manual JSON Mapping: Because Sortable.js rearranges the actual input elements in the DOM, htmx's standard form submission naturally sends the correct sequence without any custom data mapping.","Visual Feedback: By targeting the list body and returning a partial, you can update \"Order\" badges or other sequence-dependent UI elements immediately after the drop.","Resilient Lifecycle: Using Hyperscript's htmx:afterSwap trigger ensures the drag-and-drop functionality continues working even after the list has been updated and replaced by htmx."]}],[{"l":"File Upload"},{"l":"Implementing File Uploads with htmx and ASP.NET Core","p":["The File Upload pattern demonstrates how to handle multi-part form data using htmx while providing real-time progress tracking. This allows for a smoother user experience compared to traditional form submissions, as the page doesn't need to refresh, and the user can see exactly how much of their file has been uploaded."]},{"l":"The Frontend: Razor & htmx","p":["In our FileUpload demo, we use hx-encoding='multipart/form-data' to ensure the browser sends the file correctly. We also include a progress element that htmx will update during the upload process.","_javascript.cshtml","Key htmx attributes used:","hx-encoding='multipart/form-data': This is required for any form that includes a file input. It tells htmx to use a FormData object for the request.","hx-post: Sends the file data to the Upload handler on the server."]},{"l":"Progress Tracking with JavaScript","p":["While htmx handles the upload, we use a small snippet of JavaScript to listen for the htmx:xhr:progress event and update our progress bar.","file-upload.js"]},{"l":"The Backend: C# PageModel","p":["On the server, the IndexModel receives the file as an IFormFile. It performs validation on the file size and extension before processing it.","Index.cshtml.cs"]},{"l":"Summary","p":["Integrating file uploads with htmx is straightforward. By setting the correct encoding and handling the htmx:xhr:progress event, you can create a modern, responsive file upload interface with minimal custom JavaScript. The server continues to handle the file logic exactly as it would in a traditional ASP.NET Core application, making it easy to implement robust validation and storage logic."]}],[{"l":"Infinite Scroll"},{"l":"Implementing Infinite Scroll with htmx and ASP.NET Core","p":["The Infinite Scroll pattern provides a seamless browsing experience where new content is automatically loaded as the user reaches the bottom of the list. This is a popular alternative to traditional pagination, often seen in social media feeds and product listings."]},{"l":"The Frontend: Razor & htmx","p":["In Index.cshtml, we start with a standard table. The initial set of rows is rendered via a partial view.","Index.cshtml","The key logic resides in the _PageResult.cshtml partial. It iterates through the contacts and specifically marks the last row of the current set with htmx attributes to trigger the next load.","_PageResult.cshtml","Key htmx attributes used:","hx-get: Requests the next page of data from the server.","hx-trigger=revealed: This is the \"magic\" attribute. It tells htmx to fire the request as soon as the element becomes visible in the viewport (i.e., when the user scrolls to it).","hx-swap=afterend: Instead of replacing the target, this appends the returned HTML after the current element, effectively extending the table rows."]},{"l":"The Backend: C# PageModel","p":["The server-side code handles the request for the next page. It tracks the current page number and returns a partial view containing the next batch of contacts.","Index.cshtml.cs"]},{"l":"Why this works well","p":["Superior UX: Users can continue reading without having to stop and click a \"Next\" button.","Efficient Loading: Data is only fetched when the user actually scrolls to it, saving bandwidth and server resources for users who only view the top of the list.","Simple Implementation: Unlike complex JavaScript solutions that require monitoring scroll events and calculating offsets, htmx handles the intersection observation automatically via the revealed trigger.","Natural Extension: Using hx-swap=afterend on the last row naturally appends the next set of rows to the existing table structure."]}],[{"l":"Keyboard Shortcuts"},{"l":"Implementing Keyboard Shortcuts with htmx and Hyperscript","p":["The Keyboard Shortcuts pattern demonstrates how to add global hotkeys to your web application using Hyperscript and htmx. This provides a \"desktop-like\" feel, allowing power users to navigate and trigger actions quickly without relying solely on the mouse."]},{"l":"1. Defining Global Shortcuts","p":["In Index.cshtml, we define the keyboard shortcuts on the main container using Hyperscript's _ attribute. We listen for keydown events from the global window object to ensure they are captured regardless of where the focus is.","Index.cshtml","Key components of the Hyperscript logic:","on keydown[...] from window: Listens for key presses globally.","[(altKey or metaKey) and shiftKey and key == '1']: Filters the event. We use both altKey(Windows) and metaKey(Mac Command key) plus shiftKey to avoid overriding default browser shortcuts.","click #btn1: Programmatically clicks the button, which then triggers its hx-post request.","focus() #search-input: For the \"S\" shortcut, we explicitly move focus to the search field, but only if the user isn't already inside another input."]},{"l":"2. Local Trigger Filters","p":["htmx also allows you to filter triggers directly on elements. In the search input, we only want to submit the search when the user presses the Enter key.","hx-trigger=keyup[key=='Enter']: This tells htmx to only perform the POST request if the keyup event was specifically for the Enter key."]},{"l":"3. The Backend: C# PageModel","p":["The server-side handlers are standard Razor Page methods. They process the request and return an HTML fragment (or a simple string) to be swapped into the target element.","Index.cshtml.cs"]},{"l":"Why this works well","p":["Declarative Shortcuts: You don't need to write complex JavaScript event listeners or manage addEventListener/ removeEventListener manually.","Unified Action Logic: By triggering a click on existing buttons, you reuse the same htmx logic for both mouse and keyboard users.","Cross-Platform Support: By checking for altKey or metaKey, you provide a consistent experience for both Windows and Mac users.","Improved Accessibility: Keyboard shortcuts make the application more efficient for power users and provide an alternative navigation method for users with motor impairments."]}],[{"l":"Dialogs with Custom htmx"},{"l":"Implementing Custom Dialogs with htmx and Hyperscript","p":["The Custom Dialog pattern shows how to build fully interactive \"Confirm\" and \"Prompt\" modals from scratch using only htmx and Hyperscript. This approach gives you total control over the styling and animation of your dialogs without requiring a heavy CSS framework like Bootstrap or UIKit for the modal logic."]},{"l":"1. Defining the Custom Modal Styles","p":["In Index.cshtml, we define basic CSS for our modal overlay and content. We use CSS transitions to handle the fade-in and slide-down animations.","Index.cshtml (Partial)"]},{"l":"2. Triggering the Modal","p":["The main page contains buttons that fetch the modal HTML from the server and inject it into a container.","Index.cshtml"]},{"l":"3. Managing the Lifecycle with Hyperscript","p":["The partial view uses Hyperscript(the _ attribute) to handle animations and cleanup. This replaces the JavaScript logic typically found in UI frameworks.","_ConfirmModal.cshtml","on load add .show to me: Triggers the CSS transition for fade-in.","on htmx:beforeOnLoad: When the user clicks \"Yes\" and the server responds successfully, we reverse the animation, wait for it to finish ( wait 300ms), and then remove me from the DOM.","The Cancel button uses Hyperscript to perform the same closing animation and cleanup without making a server request."]},{"l":"4. The Backend: C# PageModel","p":["The Index.cshtml.cs handles the requests for the modals and the actions they trigger.","Index.cshtml.cs"]},{"l":"Why this works well","p":["Zero Dependencies: You don't need a large UI library to manage your dialogs. htmx handles the content delivery, and Hyperscript handles the interactivity.","Total Design Control: Since the CSS is yours, you can make the modals look and behave exactly how you want.","Clean DOM: The remove me logic ensures that the modal is completely purged from the document once it's closed, keeping your page lightweight.","Declarative Logic: The animation and lifecycle logic are defined directly on the elements they affect, making the code much easier to follow than traditional jQuery or vanilla JS modal implementations."]}],[{"l":"Inline Validation"},{"l":"Implementing Inline Validation with htmx and ASP.NET Core","p":["The Inline Validation pattern allows you to provide immediate feedback to users as they fill out a form, without waiting for a full form submission. This is particularly useful for tasks like checking if an email address is already in use or validating complex input requirements."]},{"l":"The Frontend: Razor & htmx","p":["In the InlineValidation demo, the main form includes a partial view for the email field. This field is configured to validate itself independently.","Index.cshtml","The validation logic is defined within the _EmailField.cshtml partial. It uses htmx to trigger a validation check whenever the input changes.","_EmailField.cshtml","Key htmx attributes used:","hx-post: Sends the current value of the email field to the OnPostEmail handler. By default, for inputs, this is triggered by the change event.","hx-target=this: Ensures the server's response replaces the entire validation container (the wrapping div).","hx-swap=outerHTML: Replaces the entire container so that the error classes and messages can be updated.","hx-indicator=#ind: Shows a loading spinner while the server is validating the input."]},{"l":"The Backend: C# PageModel","p":["On the server, the IndexModel handles both the individual field validation and the final form submission. The OnPostEmail handler performs the inline check and returns the partial view.","Index.cshtml.cs"]},{"l":"Why this works well","p":["Immediate Feedback: Users know instantly if their input is invalid or if a username/email is taken, reducing frustration at the end of a long form.","Logic Reuse: The same validation logic can be used for both the inline htmx check and the final server-side form processing.","Clean Separation: The validation UI (errors, styles) is encapsulated within a partial view, making the main form template easier to read.","No Custom JavaScript: You get rich, asynchronous validation behavior using only standard ASP.NET Core tools and declarative htmx attributes."]}],[{"l":"Dialogs with UIKit"},{"l":"Implementing UIKit Dialogs with htmx and ASP.NET Core","p":["The Dialog UIKit pattern demonstrates how to integrate htmx with the UIKit CSS framework to create interactive, server-driven \"Confirm\" and \"Prompt\" dialogs. By fetching modal content on-demand and using Hyperscript to manage the UIKit lifecycle, you can create a seamless and responsive user experience."]},{"l":"1. Triggering the UIKit Modal","p":["In Index.cshtml, we use standard htmx attributes to request the modal content and inject it into a dedicated container.","Index.cshtml","hx-get=?handler=ConfirmModal: Fetches the partial view for the modal.","hx-target=#modal-container: Targets the container where the modal will be injected.","hx-swap=innerHTML: Replaces the contents of the container with the new modal HTML."]},{"l":"2. The Modal Lifecycle with Hyperscript","p":["Because UIKit modals require JavaScript to initialize and display, we use Hyperscript(the _ attribute) to handle these events declaratively.","_ConfirmModal.cshtml","on load call UIkit.modal(me).show(): Shows the modal as soon as it's injected into the DOM.","on htmx:beforeOnLoad: Hides the modal immediately after the confirmation action is successfully processed.","on hidden remove me: Automatically removes the modal element from the DOM once it's finished closing, preventing \"DOM clutter.\""]},{"l":"3. Handling Prompts and Input","p":["The Prompt pattern follows the same logic but includes a form to capture user input.","_PromptModal.cshtml","When the form is submitted, htmx sends the promptValue to the server, and the Hyperscript on the parent div handles closing the dialog."]},{"l":"4. The Backend: C# PageModel","p":["The Index.cshtml.cs file contains the handlers for returning the modals and processing the actions.","Index.cshtml.cs"]},{"l":"Why this works well","p":["Framework Flexibility: This demonstrates that htmx isn't tied to any specific CSS framework; it works just as well with UIKit as it does with Bootstrap.","Declarative Interactivity: Using Hyperscript allows you to keep your modal logic right in the HTML, avoiding the need for separate, complex JavaScript files to manage modal states.","On-Demand Loading: Modals are only loaded when needed, reducing the initial weight of the page and keeping the DOM lean.","Clean State Management: By removing the modal from the DOM on hidden, you ensure that every \"Open\" click starts with a fresh, clean state."]}],[{"l":"Lazy Loading"},{"l":"Boosting Page Performance: Lazy Loading with htmx and ASP.NET Core Razor Pages","p":["In modern web development, speed is everything. A slow-loading dashboard can frustrate users and lead to higher bounce rates. One of the most effective techniques to improve perceived performance is Lazy Loading—deferring the loading of non-critical, heavy components until after the main page is ready.","In this post, we’ll explore how to implement lazy loading in an ASP.NET Core Razor Pages project using htmx."]},{"l":"The Scenario","p":["Imagine a \"Sales Performance Dashboard\" with two heavy components:","Sales by Region Chart: Requires complex data aggregation.","Recent Activity Feed: Fetches data from a slow external API.","Instead of making the user wait for these components to load before seeing the page, we’ll load the shell immediately and pull the data in asynchronously."]},{"l":"1. The Backend: Named Page Handlers","p":["In Razor Pages, we can use Named Handlers to return partial views independently. In our Index.cshtml.cs, we define two handlers: OnGetSalesChart and OnGetRecentActivity."]},{"l":"2. The Frontend: htmx Magic","p":["Using htmx, we can trigger these handlers as soon as the page loads using the hx-trigger=load attribute.","In Index.cshtml, we set up containers with \"skeletons\" or loading spinners. htmx will automatically replace these placeholders with the returned HTML once the server responds."]},{"l":"3. The Partial Views","p":["The partial views (_SalesChart.cshtml and _RecentActivity.cshtml) contain only the HTML fragment needed for those specific widgets. For example, the _SalesChart.cshtml might look like this:"]},{"l":"Why This Works","p":["Instant Feedback: The user sees the dashboard layout and navigation immediately.","Parallel Loading: Both widgets start loading at the same time, without blocking the main thread.","No Custom JavaScript: We achieved a complex asynchronous behavior using only standard ASP.NET Core patterns and a few htmx attributes."]},{"l":"Conclusion","p":["Lazy loading with htmx and Razor Pages is a powerful combination. It allows you to keep your backend logic in C# while providing the snappy, reactive experience users expect from modern web applications."]}],[{"l":"Dialogs with Bootstrap"},{"l":"Implementing Browser-Style Dialogs with htmx and Bootstrap","p":["The Dialog Browser pattern demonstrates how to replace native browser dialogs like confirm() and prompt() with rich, custom-styled Bootstrap modals using htmx. This allows you to maintain a consistent UI/UX while still leveraging server-side logic for confirmation and input processing."]},{"l":"1. Triggering the Modal","p":["In Index.cshtml, we have buttons that request the modal content from the server. Instead of the modal being hidden in the DOM, it is fetched on-demand.","Index.cshtml","hx-get=?handler=ConfirmModal: Calls the server to get the modal HTML fragment.","hx-target=#modal-container: Injects the modal into a dedicated container at the bottom of the page."]},{"l":"2. The Modal Fragment (with Hyperscript)","p":["The partial view contains the Bootstrap modal structure. We use a small amount of Hyperscript(the _ attribute) to handle the Bootstrap lifecycle (showing the modal and removing it from the DOM after it's hidden).","_ConfirmModal.cshtml","Hyperscript logic: On load, it initializes and shows the Bootstrap modal. On htmx:beforeOnLoad(when the \"Yes\" action finishes successfully), it hides the modal. On hidden.bs.modal, it cleans up by removing itself from the DOM.","hx-get=?handler=ConfirmAction: The actual action performed once the user confirms."]},{"l":"3. Handling Prompts","p":["The Prompt pattern is similar but uses a form inside the modal to capture user input.","_PromptModal.cshtml","When the form is submitted, htmx sends the promptValue to the server, updates the target on the main page, and the Hyperscript on the wrapping div handles closing the modal."]},{"l":"4. The Backend: C# PageModel","p":["The Index.cshtml.cs handles returning the partial views for the modals and the final actions triggered from within them.","Index.cshtml.cs"]},{"l":"Why this works well","p":["UX Consistency: You can style these dialogs to perfectly match your application's theme, unlike native browser dialogs.","Server-Side Templates: You don't need to write complex JavaScript to build modals or manage their state; the server provides the HTML.","Automatic Cleanup: Using Hyperscript to remove me on hidden ensures that your DOM doesn't get cluttered with orphaned modal elements.","Native Fallback: For simple cases, you can still use the built-in hx-confirm=Message attribute for a quick native browser confirmation without any extra templates."]}],[{"l":"Progress Bar"},{"l":"Implementing a Progress Bar with htmx and ASP.NET Core","p":["The Progress Bar pattern is essential for long-running tasks. It allows you to initiate a process on the server and provide real-time updates to the user without a full page reload, improving the perceived performance and user experience of your application."]},{"l":"1. Starting the Job","p":["In Index.cshtml, we have a simple button that triggers the long-running process. When clicked, it replaces the current container with the initial progress UI."]},{"l":"2. Polling for Status","p":["The server returns the _Progress.cshtml partial. This partial contains the logic to poll the server for the current job status.","_Progress.cshtml","Key htmx attributes used:","hx-get: Fetches the current progress from the JobStatus handler.","hx-trigger=every 600ms: Tells htmx to poll the server every 600 milliseconds while the status is \"Running\".","hx-trigger=done: Listens for a custom done event from the server to finalize the UI."]},{"l":"3. The Progress Bar Fragment","p":["The actual progress bar is rendered in a separate partial view, making it easy to update during polling.","_ProgressBar.cshtml"]},{"l":"4. The Backend: C# PageModel","p":["The IndexModel manages the state of the job and handles the polling requests.","Index.cshtml.cs"]},{"l":"Why this works well","p":["Server-Driven State: The server maintains the truth about the job's progress. The client simply polls and renders the current state.","Clean Completion: By using the HX-Trigger header, the server can tell htmx to stop polling and switch to a \"Completed\" view without the client needing complex logic.","Low Resource Usage: Polling occurs only while the job is active, and each request returns a tiny fragment of HTML, minimizing overhead.","Accessibility: By updating the aria-valuenow and progress bar width dynamically, the UI remains accessible to screen readers."]}],[{"l":"Tabs"},{"l":"Implementing Tabs with htmx and ASP.NET Core","p":["The Tabs pattern is a classic UI element for organizing content. With htmx, you can create a dynamic tabbing system that loads content asynchronously, reducing the initial page weight and making the interface feel snappy and modern."]},{"l":"1. The Container and Initial Load","p":["In Index.cshtml, we define a container for our tabs. We use htmx to automatically load the first tab when the page is ready.","Index.cshtml","hx-get=/Tabs/tab1: Requests the content for the first tab from the server.","hx-trigger=load delay:100ms: Automatically fires the request 100ms after the page loads.","hx-target=#tabs: Replaces the content of the div with the returned HTML."]},{"l":"2. The Tab Partial View","p":["Each tab is represented by a partial view that includes the tab navigation and the specific content for that tab. When a user clicks a different tab, htmx fetches the corresponding partial view and replaces the entire tab structure.","_tab1.cshtml","hx-get: Each button is wired to fetch its respective tab content.","class=selected: The active tab is styled differently to provide visual feedback.","Because the hx-target=#tabs was defined on the parent container in Index.cshtml, and htmx attributes are inherited, clicking any button in the partial will replace the content of the #tabs div."]},{"l":"3. The Backend: C# PageModel","p":["The server-side logic is straightforward. The IndexModel provides handlers for each tab, returning the appropriate partial view fragment.","Index.cshtml.cs"]},{"l":"Why this works well","p":["Lazy Loading: Content for secondary tabs is only fetched when requested, speeding up the initial page load for heavy content.","Simplified State: You don't need to manage \"active\" classes or \"hidden\" attributes in JavaScript. The server simply returns the HTML for the tab in its \"active\" state.","Encapsulation: Each tab's logic and view are contained within its own partial view, making the code easier to maintain and extend.","No Client-Side Routing: You get the benefits of dynamic content switching without the complexity of a client-side router or a heavy SPA framework."]}],[{"l":"Value Select"},{"l":"Implementing Cascading Selects with htmx and ASP.NET Core","p":["The Cascading Selects pattern (also known as dependent selects) is a common UI requirement where the options in one dropdown list depend on the selection made in a previous dropdown. htmx makes this incredibly simple by allowing you to fetch and swap the dependent dropdown's content asynchronously."]},{"l":"The Frontend: Razor & htmx","p":["In Index.cshtml, we have two select elements. The first select (Make) is configured to trigger an htmx request whenever its value changes.","Index.cshtml","Key htmx attributes used:","hx-get: Initiates a GET request to the Models handler when the user selects a different \"Make\".","hx-target=#models: Specifies that the HTML returned by the server (the new list of options) should be placed inside the element with the ID models.","name=make: htmx automatically includes the value of the select element in the request as a query parameter named make."]},{"l":"The Backend: C# PageModel","p":["The IndexModel manages the data for the manufacturers and their corresponding models. It uses a Dictionary to store the relationships and provides a handler to return the filtered models.","Index.cshtml.cs"]},{"l":"The Result: Partial View","p":["The _modelSelector.cshtml partial view simply renders the option elements for the model dropdown.","_modelSelector.cshtml"]},{"l":"Why this works well","p":["Cleaner Logic: You don't need to ship a massive JSON object containing every possible combination of data to the client.","Reduced Complexity: There is no need for custom JavaScript to clear, filter, or rebuild the second dropdown.","Server-Side Control: The server remains the source of truth for the available options, making it easy to integrate with a database or external API.","Instant Feedback: The UI updates immediately upon selection, providing a smooth and responsive experience for the user."]}],[{"l":"Animations"},{"l":"Implementing Animations with htmx and ASP.NET Core","p":["Animations are essential for creating modern, polished web experiences. They provide visual feedback, guide user attention, and make state transitions feel natural rather than jarring. With htmx, you can achieve rich animations without complex JavaScript frameworks—just CSS transitions and a few strategic htmx attributes.","The key insight is that htmx swaps are CSS-friendly. When htmx swaps content, it temporarily adds CSS classes like htmx-swapping and htmx-settling to elements, giving you perfect hooks to trigger CSS animations and transitions at exactly the right moments."]},{"l":"Why Animations Matter","p":["Visual Continuity: Smooth transitions help users understand what changed and where to look next","Perceived Performance: Well-timed animations can make your app feel faster by keeping users engaged during updates","Error Feedback: Shake animations or color flashes immediately communicate validation errors","Professional Polish: Thoughtful animations elevate a functional interface into a delightful user experience"]},{"l":"Animation Patterns Covered","p":["This section demonstrates eight practical animation techniques you can use in your htmx applications:","Color Change: Flash background colors to highlight updated content","Fade Out on Swap: Smoothly fade out old content before replacing it","Fade In on Addition: Gently introduce new elements to the page","Slide and Expand: Reveal content with smooth height and opacity transitions","Crossfade Swap: Blend between old and new content with overlapping fades","Validation Shake: Use attention-grabbing shake effects for form errors","Indicator Morphing: Transform loading indicators into final content","Request in Flight (Settling): Animate content during htmx's \"settling\" phase","Each pattern leverages htmx's swap lifecycle and CSS transitions to create smooth, declarative animations with minimal code. You'll see how to combine hx-swap modifiers like swap:500ms and CSS classes to achieve professional results while keeping your logic server-side in C# and Razor Pages."]}],[{"l":"Chinook Music Store (Work in Progress)"},{"l":"Introduction","p":["The Chinook Music Store is a real-world demonstration application that showcases how htmx can transform traditional ASP.NET Core Razor Pages applications into modern, interactive web experiences—without the complexity of a full-blown Single Page Application (SPA)."]},{"l":"About the Chinook Database","p":["The Chinook database is a widely-used sample database representing a fictitious online music store that sells digital music. It includes realistic entities like artists, albums, tracks, customers, invoices, and playlists, making it an ideal foundation for demonstrating practical web application patterns."]},{"l":"Why This Application Exists","p":["Most developers today assume that building a modern, interactive business application requires:","A complex SPA framework (React, Angular, Vue) managing client-side state","A separate backend API layer with dozens of endpoints","Complicated authentication using JWT tokens and OAuth flows","Build pipelines, bundlers, and intricate deployment processes","The Chinook Music Store challenges this assumption. It demonstrates that you can build rich, interactive user experiences using a simpler, server-first approach with htmx and ASP.NET Core Razor Pages. This approach offers:","Server-owned business logic and validation- Your domain rules live where they belong","Reduced complexity- No client-side state management, no API versioning headaches, no JWT token juggling","Better developer experience- Write C# for both UI rendering and business logic","Progressive enhancement- The application works without JavaScript and enhances with htmx","Simpler deployment- One application, one deployment target, fewer moving parts"]},{"l":"Explore the Application","p":["Live Demo: https://chinook-razor-htmx-hfg2ehd2dfgeg0bw.centralus-01.azurewebsites.net/","Source Code: https://github.com/cwoodruff/chinook-razor-htmx","The Chinook Music Store serves as a companion to this workshop, illustrating how the patterns you've learned—fragment-first design, partial updates, real-time validation, and hypermedia-driven interactions—scale to a complete business application with real-world requirements."]},{"l":"What You'll See","p":["The application demonstrates practical implementations of:","Browse and search functionality across artists, albums, and tracks","Shopping cart interactions without page reloads","Customer management and order processing","Playlist creation and management","Real-time filtering and pagination","Form validation and error handling","All built using the server-first, hypermedia-driven patterns from this workshop","This isn't a toy example or a proof-of-concept. It's a fully-functional music store that proves you can deliver modern web experiences without the architectural complexity that has become the default in modern web development."]}]]